{"time": {"13": 19082, "14": 18894, "16": 19061}, "prompt": {"13": "void Solver::bump_var(int var, double coeff) {\n    double increment = var_inc * coeff;\n    activity[var] += increment;\n\n    // Check if the activity goes beyond the threshold and rescale if needed\n    if (activity[var] > 1e100) {\n        // Instead of calculating the average, we use a fixed rescale factor\n        // This avoids the overhead of looping through all variables every time we rescale\n        double rescale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= rescale_factor;\n        var_inc *= rescale_factor;\n    }\n\n    // Update the variable in the heap if it's there\n    if (vsids.inHeap(var)) vsids.update(var);\n\n    // Apply a less aggressive decay to the increment to maintain its impact over time\n    // This is a compromise between too frequent decay and too aggressive increment\n    var_inc *= 0.999;\n}", "14": "void Solver::bump_var(int var, double coeff) {\n    double increment = var_inc * coeff;\n\n    // Check if adding the increment would cause an overflow\n    if (activity[var] + increment > 1e100) {\n        // Rescale all activities by a smaller factor to avoid frequent rescaling\n        double rescale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= rescale_factor;\n        var_inc *= rescale_factor;\n    } else {\n        activity[var] += increment;\n    }\n\n    // Update the variable in the heap if it's there\n    if (vsids.inHeap(var)) vsids.update(var);\n\n    // Apply a slight decay to the increment to ensure diversity over time\n    var_inc *= 0.999;\n}", "16": "void Solver::bump_var(int var, double coeff) {\n    double increment = var_inc * coeff;\n    activity[var] += increment;\n\n    // If the activity goes beyond a certain threshold, rescale all activities\n    if (activity[var] > 1e100) {\n        double rescale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) {\n            activity[i] *= rescale_factor;\n        }\n        var_inc *= rescale_factor;\n    }\n\n    // Update the variable in the heap if it's there\n    if (vsids.inHeap(var)) {\n        vsids.update(var);\n    }\n\n    // Apply a decay to the increment to reduce its impact over time\n    // This decay is less aggressive than the previous experiment to avoid diminishing the importance of recently conflicted variables too quickly\n    var_inc *= 0.999;\n}"}}