{"time": {"1": 18363, "2": 15534, "4": 17191}, "prompt": {"1": "void Solver::bump_var(int var, double coeff) {\n    activity[var] += var_inc * coeff; // Increase the activity of the variable\n    if (activity[var] > 1e100) {     // Check for overflow\n        // Rescale all activities if overflow is imminent\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100; // Adjust the increment as well\n    }\n    // Use a more aggressive strategy by increasing the increment factor\n    var_inc *= (1 / 0.95); // You can adjust this value as needed\n\n    // Update the variable in the heap if it's there\n    if (vsids.inHeap(var)) vsids.update(var);\n}", "2": "void Solver::bump_var(int var, double coeff) {\n    double increment = var_inc * coeff;\n    // Check if adding the increment would cause an overflow\n    if (activity[var] > 1e100 - increment) {\n        // Scale down all activities to prevent overflow\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100; // Adjust var_inc accordingly\n    }\n    activity[var] += increment; // Safely add the increment now\n    if (vsids.inHeap(var)) vsids.update(var); // Update the variable in the heap\n}", "4": "void Solver::bump_var(int var, double coeff) {\n    if (var >= 1 && var <= vars) { // Ensure the variable index is within the valid range\n        activity[var] += var_inc * coeff;\n        if (activity[var] > 1e100) { // Rescale the activities to prevent overflow\n            for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n            var_inc *= 1e-100; // Adjust var_inc accordingly\n        } else if (activity[var] < 1e-100) { // Rescale to prevent underflow\n            for (int i = 1; i <= vars; i++) activity[i] *= 1e100;\n            var_inc *= 1e100; // Adjust var_inc accordingly\n        }\n        if (vsids.inHeap(var)) vsids.update(var); // Update the variable in the heap\n    }\n}"}}