{"time": {"5": 17425, "6": 15548, "8": 17541}, "prompt": {"5": "void Solver::bump_var(int var, double coeff) {\n    double increment = var_inc * coeff;\n    // Check if adding the increment would cause an overflow\n    if (activity[var] + increment > 1e100) {\n        // Scale down all activities to prevent overflow\n        double rescale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= rescale_factor;\n        var_inc *= rescale_factor; // Adjust var_inc accordingly\n    } else {\n        activity[var] += increment; // Safely add the increment now\n    }\n\n    // Update the variable in the heap if it's there\n    if (vsids.inHeap(var)) vsids.update(var);\n\n    // Dynamically adjust the increment value based on the variable's activity\n    // This can help to escape from local optima by giving a boost to variables that are not currently active\n    if (activity[var] < 1e-20) {\n        var_inc *= 1.05; // Slightly increase the increment if the activity is too low\n    }\n}", "6": "void Solver::bump_var(int var, double coeff) {\n    double increment = var_inc * coeff;\n    // Check if adding the increment would cause an overflow\n    if (activity[var] + increment > 1e150) { // Increased threshold to reduce frequency of rescaling\n        // Scale down all activities to prevent overflow\n        double rescale_factor = 1e-150;\n        for (int i = 1; i <= vars; i++) activity[i] *= rescale_factor;\n        var_inc *= rescale_factor; // Adjust var_inc accordingly\n    }\n    activity[var] += increment; // Safely add the increment now\n    // Update the variable in the heap if it's there\n    if (vsids.inHeap(var)) vsids.update(var);\n}", "8": "void Solver::bump_var(int var, double coeff) {\n    static const int check_interval = 1000; // Interval for overflow checks\n    static int check_counter = check_interval; // Counter for overflow checks\n\n    // Increase the activity of the variable\n    activity[var] += var_inc * coeff;\n\n    // Only check for overflow every 'check_interval' invocations\n    if (--check_counter == 0) {\n        check_counter = check_interval;\n        // Check for overflow\n        if (activity[var] > 1e100) {\n            // Scale down all activities to prevent overflow\n            for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n            var_inc *= 1e-100; // Adjust var_inc accordingly\n        }\n    }\n\n    // Update the variable in the heap if it's there\n    if (vsids.inHeap(var)) vsids.update(var);\n}"}}