{"time": {"10": 36, "11": 33, "12": 34, "9": 32}, "prompt": {"10": "void Solver::bump_var(int var, double coeff) {\n    activity[var] += var_inc * coeff; // Increase the activity by the increment times the coefficient\n    bool rescale_needed = activity[var] > 1e100;\n\n    // Use a more aggressive dynamic scaling factor to adapt the increment over time\n    var_inc *= (1 / 0.88); // Increase the increment factor more aggressively to adapt to the problem's hardness\n\n    // Only update the heap if there's a significant change in activity or if rescaling is needed\n    if (vsids.inHeap(var) && (rescale_needed || activity[var] > activity[var] * 1.04)) {\n        vsids.update(var); // Update the variable in the heap if it's there\n    }\n\n    // Perform rescaling if needed for all variables at once\n    if (rescale_needed) {\n        double rescale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) {\n            activity[i] *= rescale_factor; // Scale down all activities\n        }\n        var_inc *= rescale_factor; // Scale down the increment as well\n    }\n}", "11": "void Solver::bump_var(int var, double coeff) {\n    double old_activity = activity[var];\n    activity[var] += var_inc * coeff; // Increase the activity by the increment times the coefficient\n    \n    // Introduce a threshold to avoid unnecessary updates when the activity is already high\n    const double activity_threshold = 1e100;\n    const double rescale_factor = 1e-100;\n    const double update_threshold = 1.05;\n    const double increment_aggression = 1 / 0.88; // Slightly more aggressive than before\n\n    // Check if we need to rescale to avoid floating point overflow\n    if (activity[var] > activity_threshold) {\n        // Perform rescaling if needed for all variables at once\n        bool rescale_needed = false;\n        for (int i = 1; i <= vars; i++) {\n            if (activity[i] > activity_threshold) {\n                rescale_needed = true;\n                break;\n            }\n        }\n        if (rescale_needed) {\n            for (int i = 1; i <= vars; i++) {\n                activity[i] *= rescale_factor; // Scale down all activities\n            }\n            var_inc *= rescale_factor; // Scale down the increment as well\n        }\n    }\n\n    // Use a more aggressive dynamic scaling factor to adapt the increment over time\n    var_inc *= increment_aggression;\n\n    // Only update the heap if there's a significant change in activity\n    if (vsids.inHeap(var) && activity[var] > old_activity * update_threshold) {\n        vsids.update(var); // Update the variable in the heap if it's there\n    }\n}", "12": "void Solver::bump_var(int var, double coeff) {\n    double old_activity = activity[var];\n    activity[var] += var_inc * coeff; // Increase the activity by the increment times the coefficient\n    bool in_heap = vsids.inHeap(var); // Store the heap status to avoid checking twice\n\n    // Check if we need to rescale to avoid floating point overflow\n    if (activity[var] > 1e100) {\n        double rescale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++)\n            activity[i] *= rescale_factor; // Scale down all activities\n        var_inc *= rescale_factor; // Scale down the increment as well\n    }\n\n    // Use a more aggressive dynamic scaling factor to adapt the increment over time\n    var_inc *= (1 / 0.85); // Increase the increment factor more aggressively to adapt to the problem's hardness\n\n    // Only update the heap if there's a significant change in activity and the variable is in the heap\n    if (in_heap && (activity[var] > old_activity * (1.0 + var_inc / 10.0))) {\n        vsids.update(var); // Update the variable in the heap if it's there\n    }\n}", "9": "void Solver::bump_var(int var, double coeff) {\n    activity[var] += var_inc * coeff; // Increase the activity by the increment times the coefficient\n    if (activity[var] > 1e100) { // Check if we need to rescale to avoid floating point overflow\n        double rescale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++)\n            activity[i] *= rescale_factor; // Scale down all activities\n        var_inc *= rescale_factor; // Scale down the increment as well\n    }\n    // Adjust the increment factor more dynamically based on the coefficient\n    var_inc *= (1 / (0.8 + 0.1 * coeff)); // Increase the increment factor based on the coefficient to adapt to the problem's hardness\n    // Update the heap if the variable is in the heap and the activity has been increased significantly\n    if (vsids.inHeap(var) && activity[var] > activity[var] / (1 + var_inc * coeff)) {\n        vsids.update(var); // Update the variable in the heap if it's there\n    }\n}"}}