{"time": {"5": 11060, "7": 10933}, "prompt": {"5": "void Solver::bump_var(int var, double coeff) {\n    // Dynamically adjust the coefficient based on the activity and number of conflicts\n    double dynamic_coeff = coeff * (conflicts > 1000 ? 2.0 : 1.0) * (activity[var] < 0.5 ? 2.0 : 1.0);\n    \n    // Increase the activity of the variable by the increment times the dynamic coefficient.\n    activity[var] += var_inc * dynamic_coeff;\n    \n    // Check for floating-point overflow.\n    if (activity[var] > 1e100) {\n        // Scale down all activities to prevent overflow.\n        for (int i = 1; i <= vars; i++) {\n            activity[i] *= 1e-100;\n        }\n        // Scale down the increment as well.\n        var_inc *= 1e-100;\n    }\n    \n    // Update the variable in the heap if it's there.\n    if (vsids.inHeap(var)) {\n        vsids.update(var);\n    }\n    \n    // Apply a decay factor to the increment (e.g., 0.95).\n    var_inc *= (1 / 0.95);\n}", "7": "void Solver::bump_var(int var, double coeff) {\n    activity[var] += var_inc * coeff; // Increase the activity of the variable by the increment times the coefficient.\n    if (activity[var] > 1e100) {     // Check for floating-point overflow.\n        double rescale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) {\n            activity[i] *= rescale_factor; // Scale down all activities to prevent overflow.\n        }\n        var_inc *= rescale_factor;        // Scale down the increment as well.\n    }\n    if (vsids.inHeap(var)) {\n        vsids.update(var);                // Update the variable in the heap if it's there.\n    }\n    // Apply a decay factor to the increment only when a conflict is found.\n    // This is indicated by a non-zero coefficient, which suggests that the variable is involved in a conflict.\n    if (coeff > 0) {\n        var_inc *= (1 / 0.95);            // Decay the increment factor (e.g., 0.95).\n    }\n}"}}