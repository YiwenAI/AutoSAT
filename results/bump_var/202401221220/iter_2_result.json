{
  "time": {
    "10": 13414,
    "11": 13268,
    "9": 12214
  },
  "prompt": {
    "10": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity of the variable by the increment times the coefficient.\n    activity[var] += var_inc * coeff;\n    \n    // Check if we need to rescale to prevent floating-point overflow.\n    if (activity[var] > 1e100) {\n        // Scale down all activities to keep numbers manageable.\n        double rescale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) {\n            activity[i] *= rescale_factor;\n        }\n        var_inc *= rescale_factor; // Scale down the increment as well.\n    }\n    \n    // If the variable is in the heap, update its position.\n    // Otherwise, insert it into the heap.\n    if (vsids.inHeap(var)) {\n        vsids.update(var);\n    } else {\n        vsids.insert(var);\n    }\n    \n    // Apply an additional bump to the variable's activity if it's involved in a conflict.\n    // This helps to prioritize variables that are frequently part of conflicts.\n    if (coeff > 1.0) {\n        activity[var] += var_inc * (coeff - 1.0);\n        if (vsids.inHeap(var)) {\n            vsids.update(var);\n        }\n    }\n}",
    "11": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity of the variable by the increment times the coefficient.\n    activity[var] += var_inc * coeff;\n\n    // Check if we need to rescale to prevent floating-point overflow.\n    if (activity[var] > 1e100) {\n        // Scale down all activities to keep numbers manageable.\n        double rescale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) {\n            activity[i] *= rescale_factor;\n        }\n        var_inc *= rescale_factor; // Scale down the increment as well.\n    }\n\n    // Update the variable's position in the heap if it is in the heap.\n    // Since the variable's activity has increased, it may need to move up in the heap.\n    if (vsids.inHeap(var)) {\n        vsids.update(var);\n    }\n    // If the variable is not in the heap and is unassigned, insert it into the heap.\n    // This is an optimization to avoid checking the heap status when the variable is already assigned.\n    else if (value[var] == 0) {\n        vsids.insert(var);\n    }\n}",
    "9": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity of the variable by the increment times the coefficient.\n    activity[var] += var_inc * coeff;\n\n    // Check if we need to rescale to prevent floating-point overflow.\n    if (activity[var] > 1e100) {\n        // Scale down all activities to keep numbers manageable.\n        double rescale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) {\n            activity[i] *= rescale_factor;\n        }\n        var_inc *= rescale_factor; // Scale down the increment as well.\n    }\n\n    // Check if the variable is unassigned and update the heap accordingly.\n    if (value[var] == 0) {\n        // If the variable is not in the heap, insert it.\n        if (!vsids.inHeap(var)) {\n            vsids.insert(var);\n        }\n        // Update the variable's position in the heap.\n        vsids.update(var);\n    }\n}"
  }
}