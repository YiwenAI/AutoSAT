{
  "time": {
    "10": 1754.5,
    "11": 893.25
  },
  "prompt": {
    "10": "void Solver::bump_var(int var, double coeff) {\n    // Dynamic coefficient based on the ratio of recent conflicts to total conflicts\n    double recent_conflict_ratio = conflicts > 0 ? (double)fast_lbd_sum / (lbd_queue_size * conflicts) : 1;\n    double dynamic_coeff = coeff * recent_conflict_ratio;\n\n    // Adjust the increment based on the dynamic coefficient\n    double increment = var_inc * dynamic_coeff;\n\n    // Increase the activity of the variable\n    activity[var] += increment;\n\n    // Rescale to prevent overflow\n    if (activity[var] > 1e100) {\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100;\n    }\n\n    // Decay the activity of variables to promote exploration\n    double avg_lbd = slow_lbd_sum / (conflicts > 0 ? conflicts : 1);\n    double decay_factor = avg_lbd < 2.0 ? 0.99 : 0.95; // Less decay for harder problems\n    activity[var] *= decay_factor;\n\n    // Decay the increment value to avoid high activity variables getting stuck\n    var_inc *= decay_factor;\n\n    // Update the variable's position in the heap if it's there\n    if (vsids.inHeap(var)) vsids.update(var);\n}",
    "11": "void Solver::bump_var(int var, double coeff) {\n    // Parameters for activity rescaling to prevent floating-point overflows\n    const double max_activity = 1e100;\n    const double rescale_factor = 1e-100;\n\n    // Exponential moving average parameters for LBD\n    const double ema_alpha = 0.2; // Alpha for exponential moving average (between 0 and 1)\n    static double ema_lbd = 2.0;  // Initialize with a reasonable default LBD value\n\n    // Update the exponential moving average of LBD\n    if (conflicts > 0) {\n        double current_lbd = (double)slow_lbd_sum / conflicts;\n        ema_lbd = ema_alpha * current_lbd + (1 - ema_alpha) * ema_lbd;\n    }\n\n    // Calculate a dynamic coefficient based on the moving average of LBD\n    double dynamic_coeff = coeff * (1.0 / (1.0 + ema_lbd));\n\n    // Increase the variable activity and apply the dynamic coefficient\n    activity[var] += var_inc * dynamic_coeff;\n\n    // Rescale activity if it goes beyond the maximum threshold to prevent overflow\n    if (activity[var] > max_activity) {\n        for (int i = 1; i <= vars; i++) {\n            activity[i] *= rescale_factor;\n        }\n        var_inc *= rescale_factor;\n    }\n\n    // Update the variable's position in the heap if it's there\n    if (vsids.inHeap(var)) {\n        vsids.update(var);\n    }\n}"
  }
}