{
  "time": {
    "5": 968.75,
    "6": 843.75,
    "7": 1739.5,
    "8": 1756.0
  },
  "prompt": {
    "5": "void Solver::bump_var(int var, double coeff) {\n    const double max_activity = 1e100;\n    const double rescale_factor = 1e-100;\n    const double decay_factor = 0.95;\n    const double conflict_based_coeff = conflicts ? static_cast<double>(conflicts) / (conflicts + 1) : 1;\n\n    // Dynamically adjust the coefficient based on the number of conflicts\n    double dynamic_coeff = coeff * conflict_based_coeff;\n\n    // Increase activity by a scaled factor\n    activity[var] += var_inc * dynamic_coeff;\n\n    // If activity exceeds the maximum, rescale all activities\n    if (activity[var] > max_activity) {\n        for (int i = 1; i <= vars; i++) {\n            activity[i] *= rescale_factor;\n        }\n        var_inc *= rescale_factor; // Rescale the increment as well\n    }\n\n    // Apply aging to the variable activity to promote diversity\n    activity[var] *= decay_factor;\n\n    // If the variable is in the heap, update its position\n    if (vsids.inHeap(var)) {\n        vsids.update(var);\n    }\n}",
    "6": "void Solver::bump_var(int var, double coeff) {\n    double increment = var_inc * coeff;\n    double avg_lbd = slow_lbd_sum / (conflicts > 0 ? conflicts : 1);\n    double lbd_factor = avg_lbd < 2.0 ? 2.0 : avg_lbd; // Encourage diversity for harder problems\n\n    activity[var] += increment * lbd_factor;\n\n    // Rescale to prevent overflow\n    if (activity[var] > 1e100) {\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100;\n    }\n\n    // Promote variables involved in recent conflicts\n    if (conflicts > 0 && conflicts % 5000 == 0) {\n        for (int i = 1; i <= vars; i++) {\n            if (activity[i] < 1) activity[i] *= (conflicts / 5000);\n        }\n    }\n\n    // Update the variable's position in the heap if it's there\n    if (vsids.inHeap(var)) vsids.update(var);\n}",
    "7": "void Solver::bump_var(int var, double coeff) {\n    // Use LBD information to adjust the variable activity bump.\n    double lbd_avg = conflicts > 0 ? (double)slow_lbd_sum / conflicts : 0;\n    double lbd_influence = lbd_avg > 0 ? 1.0 / (1 + lbd_avg) : 1.0; // Influence decreases as LBD average increases.\n\n    // Increase activity by a scaled factor influenced by LBD.\n    activity[var] += var_inc * coeff * lbd_influence;\n\n    // Prevent activity from overflowing.\n    if (activity[var] > 1e100) {\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100;\n    }\n\n    // Promote diversity by decaying activities slightly.\n    activity[var] *= 0.98;\n\n    // Decay the increment over time to prevent variables from getting stuck with high activity.\n    var_inc *= 0.95;\n\n    // Update the variable's position in the heap if it's there.\n    if (vsids.inHeap(var)) vsids.update(var);\n}",
    "8": "void Solver::bump_var(int var, double coeff) {\n    const double max_activity = 1e100;\n    const double rescale_factor = 1e-100;\n    const double decay_factor = 0.95;\n\n    // Scale the increment based on the number of conflicts and the LBD scores\n    double dynamic_coeff = (conflicts > 1000) ? (fast_lbd_sum / lbd_queue_size) / (slow_lbd_sum / conflicts) : 1;\n    double increment = var_inc * coeff * dynamic_coeff;\n\n    // Increase the activity\n    activity[var] += increment;\n\n    // Rescale the activities if necessary to prevent overflow\n    if (activity[var] > max_activity) {\n        for (int i = 1; i <= vars; i++) {\n            activity[i] *= rescale_factor;\n        }\n        var_inc *= rescale_factor;\n    }\n\n    // Occasionally decay the activity scores to diversify the search\n    if (conflicts % 5000 == 0) {\n        for (int i = 1; i <= vars; i++) {\n            activity[i] *= decay_factor;\n        }\n    }\n\n    // Update the variable in the heap if it's there\n    if (vsids.inHeap(var)) {\n        vsids.update(var);\n    }\n}"
  }
}