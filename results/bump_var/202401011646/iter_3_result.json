{"time": {"13": 1650.25}, "prompt": {"13": "void Solver::bump_var(int var, double coeff) {\n    // Parameters for activity rescaling to prevent floating-point overflows\n    const double max_activity = 1e100;\n    const double rescale_factor = 1e-100;\n\n    // Heuristic parameters for activity bumping\n    const double var_decay = 0.95;\n    const double lbd_avg_threshold = 2.0;\n    const double lbd_weight = 0.5;\n\n    // Calculate the average LBD score of recent conflicts\n    double avg_lbd = conflicts > 0 ? (double)fast_lbd_sum / lbd_queue_size : 2.0;\n\n    // Determine the weight of the LBD in the variable activity bump\n    double lbd_factor = avg_lbd < lbd_avg_threshold ? lbd_weight : 1.0;\n\n    // Calculate the dynamic coefficient based on the LBD factor\n    double dynamic_coeff = coeff * lbd_factor;\n\n    // Bump the activity of the variable\n    activity[var] += var_inc * dynamic_coeff;\n\n    // Rescale activity if it goes beyond the maximum threshold to prevent overflow\n    if (activity[var] > max_activity) {\n        for (int i = 1; i <= vars; i++) {\n            activity[i] *= rescale_factor;\n        }\n        var_inc *= rescale_factor;\n    }\n\n    // Decay the variable increment to diversify the search\n    var_inc *= var_decay;\n\n    // Update the variable's position in the heap if it's there\n    if (vsids.inHeap(var)) {\n        vsids.update(var);\n    }\n}"}}