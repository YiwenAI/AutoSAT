{"time": {"13": 11402, "14": 14091, "15": 11383}, "prompt": {"13": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n\n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        double inv_scale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= inv_scale_factor;\n        var_inc *= inv_scale_factor; // Adjust the increment as well\n    }\n\n    // Dynamically adjust the increment factor based on the solver's state and the coefficient\n    // If the coefficient is high, it means the variable is very active and we should increase the increment more aggressively\n    if (coeff > 0.2) {\n        var_inc *= (1 / 0.85); // More aggressive increment for highly active variables\n    } else if (coeff < 0.1) {\n        var_inc *= (1 / 0.99); // Less aggressive increment for less active variables\n    }\n\n    // Update the variable in the heap if it's there and the activity has increased significantly\n    if (coeff > 0.01 && vsids.inHeap(var)) {\n        vsids.update(var);\n    }\n}", "14": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n\n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        double inv_scale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= inv_scale_factor;\n        var_inc *= inv_scale_factor; // Adjust the increment as well\n    }\n\n    // Adjust the increment factor based on the solver's performance\n    // If the solver has had many conflicts, increase the increment more aggressively\n    if (conflicts > 100000 && coeff > 0.2) {\n        var_inc *= (1 / 0.75); // More aggressive increment for highly active variables in high conflict scenarios\n    } else if (conflicts < 1000 && coeff < 0.1) {\n        var_inc *= (1 / 1.01); // Less aggressive increment for less active variables in low conflict scenarios\n    }\n\n    // Update the variable in the heap if it's there\n    // Only update the heap if the activity change is significant to avoid unnecessary heap operations\n    if (activity[var] / (var_inc * coeff) < 2 && vsids.inHeap(var)) vsids.update(var);\n}", "15": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n\n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        double inv_scale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= inv_scale_factor;\n        var_inc *= inv_scale_factor; // Adjust the increment as well\n    }\n\n    // Adjust the increment factor based on the LBD of the clauses in which the variable appears\n    int min_lbd = INT_MAX;\n    for (auto& watcher : watch(var)) {\n        Clause& clause = clause_DB[watcher.idx_clause];\n        min_lbd = std::min(min_lbd, clause.lbd);\n    }\n    if (min_lbd < 5) {\n        var_inc *= (1 / 0.85); // More aggressive increment for variables in low LBD clauses\n    } else if (min_lbd > 10) {\n        var_inc *= (1 / 0.99); // Less aggressive increment for variables in high LBD clauses\n    }\n\n    // Update the variable in the heap if it's there and the activity increment is significant\n    if (coeff > 0.01 && vsids.inHeap(var)) vsids.update(var);\n}"}}