{"time": {"10": 16419, "11": 11402, "9": 10633}, "prompt": {"10": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n    \n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        double inv_scale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= inv_scale_factor;\n        var_inc *= inv_scale_factor; // Adjust the increment as well\n    }\n    \n    // Dynamically adjust the increment factor based on the solver's state and the variable's activity\n    // If the solver is struggling, increase the increment more aggressively\n    if (fast_lbd_sum > lbd_queue_size * 2 && activity[var] < 1e-5) {\n        var_inc *= (1 / 0.85); // More aggressive increment for less active variables when struggling\n    } else if (activity[var] > 1e5) {\n        var_inc *= 0.95; // Gently decrease the increment factor for highly active variables\n    } else {\n        var_inc *= (1 / 0.95); // Standard increment otherwise\n    }\n    \n    // Update the variable in the heap if it's there\n    if (vsids.inHeap(var)) vsids.update(var);\n}", "11": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n    \n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100; // Adjust the increment as well\n    }\n    \n    // Dynamically adjust the increment factor based on the solver's state\n    // If the average LBD of learned clauses is high, increase the increment more aggressively\n    double avg_lbd = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    if (avg_lbd > 5) {\n        var_inc *= (1 / 0.85); // More aggressive increment if the average LBD is high\n    } else {\n        var_inc *= (1 / 0.95); // Standard increment otherwise\n    }\n    \n    // Consider the phase of the variable for bumping\n    if (saved[var] == (activity[var] > 0 ? 1 : -1)) {\n        activity[var] += var_inc * coeff * 0.1; // Extra bump if the current phase aligns with the saved phase\n    }\n    \n    // Update the variable in the heap if it's there\n    if (vsids.inHeap(var)) vsids.update(var);\n}", "9": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n\n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        double inv_scale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= inv_scale_factor;\n        var_inc *= inv_scale_factor; // Adjust the increment as well\n    }\n\n    // Dynamically adjust the increment factor based on the solver's state and the coefficient\n    // If the coefficient is high, it means the variable is very active and we should increase the increment more aggressively\n    if (coeff > 0.2) {\n        var_inc *= (1 / 0.85); // More aggressive increment for highly active variables\n    } else if (coeff < 0.1) {\n        var_inc *= (1 / 0.99); // Less aggressive increment for less active variables\n    }\n\n    // Update the variable in the heap if it's there\n    // Only update the heap if the coefficient is significant to avoid unnecessary heap operations\n    if (coeff > 0.01 && vsids.inHeap(var)) vsids.update(var);\n}"}}