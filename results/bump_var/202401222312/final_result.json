 {
  "0": {
    "time": 13322,
    "prompt": " "
  },
  "2": {
    "time": 14046,
    "prompt": "void Solver::bump_var(int var, double coeff) {\n    double inc = var_inc * coeff; // Calculate increment value\n    activity[var] += inc;         // Increment the activity of the variable by the calculated value\n\n    // Check if the activity exceeds a large threshold to prevent floating-point overflow\n    if (activity[var] > 1e100) {\n        // Rescale all activities to prevent overflow\n        for (int i = 1; i <= vars; i++) {\n            activity[i] *= 1e-100;\n        }\n        // Adjust the increment value accordingly\n        var_inc *= 1e-100;\n    }\n\n    // Update the variable in the heap only if the increment is significant\n    if (inc > 1e-20 && vsids.inHeap(var)) {\n        vsids.update(var);\n    }\n}"
  },
  "3": {
    "time": 10252,
    "prompt": "void Solver::bump_var(int var, double coeff) {\n    activity[var] += var_inc * coeff; // Increase the activity by the increment multiplied by the coefficient\n    if (activity[var] > 1e100) { // Check if the activity is too large to prevent overflow\n        // Normalize the activities\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100; // Adjust the increment as well\n    }\n    // Use a more aggressive strategy for increasing the increment\n    var_inc *= (1 / 0.95); // Increase the increment factor slightly\n    if (vsids.inHeap(var)) vsids.update(var); // Update the variable in the heap if it's there\n}"
  },
  "4": {
    "time": 10931,
    "prompt": "void Solver::bump_var(int var, double coeff) {\n    activity[var] += var_inc * coeff; // Increase the activity of the variable\n    if (activity[var] > 1e100) {     // Check for overflow and rescale if necessary\n        for (int i = 1; i <= vars; i++) {\n            activity[i] *= 1e-100;   // Rescale the activity to prevent overflow\n        }\n        var_inc *= 1e-100;           // Rescale the increment as well\n    }\n    if (vsids.inHeap(var)) {\n        vsids.update(var);           // Update the variable in the heap if it's there\n    }\n    // Use a more aggressive increment strategy\n    var_inc *= (1 / 0.95);           // Increase the increment factor slightly\n}"
  },
  "5": {
    "time": 12484,
    "prompt": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n\n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100; // Adjust the increment as well\n    }\n\n    // Use a more aggressive strategy for increasing the increment\n    // but ensure it doesn't grow too rapidly by capping the growth\n    var_inc = std::min(var_inc * (1 / 0.9), 1e100);\n\n    // Update the variable in the heap if it's there and the activity increment is significant\n    if (coeff > 0.01 && vsids.inHeap(var)) vsids.update(var);\n}"
  },
  "6": {
    "time": 17275,
    "prompt": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n    \n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        double inv_act = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= inv_act;\n        var_inc *= inv_act; // Adjust the increment as well\n    }\n    \n    // Dynamically adjust the increment factor based on the variable's activity\n    if (activity[var] < 1e-5) {\n        var_inc *= 1.05; // Gently increase the increment factor for less active variables\n    } else if (activity[var] > 1e5) {\n        var_inc *= 0.95; // Gently decrease the increment factor for highly active variables\n    }\n    \n    // Update the variable in the heap if it's there\n    if (vsids.inHeap(var)) vsids.update(var);\n}"
  },
  "7": {
    "time": 13104,
    "prompt": "void Solver::bump_var(int var, double coeff) {\n    activity[var] += var_inc * coeff; // Increase the activity by the increment multiplied by the coefficient\n    if (activity[var] > 1e100) { // Check if the activity is too large to prevent overflow\n        // Normalize the activities\n        double inv_scale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= inv_scale_factor;\n        var_inc *= inv_scale_factor; // Adjust the increment as well\n    }\n\n    // Dynamically adjust the increment factor based on solver performance\n    if (conflicts % 5000 == 0 && conflicts > 0) {\n        var_inc *= (1 / 0.9); // Increase the increment factor more aggressively if there are many conflicts\n    } else {\n        var_inc *= (1 / 0.99); // Otherwise, increase it more conservatively\n    }\n\n    // Update the variable in the heap if it's there and the activity bump is significant\n    if (coeff > 0.1 && vsids.inHeap(var)) vsids.update(var);\n}"
  },
  "8": {
    "time": 11208,
    "prompt": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n    \n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100; // Adjust the increment as well\n    }\n    \n    // Dynamically adjust the increment factor based on the solver's state\n    // For example, if the fast LBD sum is high, increase the increment more aggressively\n    if (fast_lbd_sum > lbd_queue_size * 2) {\n        var_inc *= (1 / 0.9); // More aggressive increment if the solver is struggling\n    } else {\n        var_inc *= (1 / 0.95); // Standard increment otherwise\n    }\n    \n    // Update the variable in the heap if it's there\n    if (vsids.inHeap(var)) vsids.update(var);\n}"
  },
  "10": {
    "time": 16419,
    "prompt": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n    \n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        double inv_scale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= inv_scale_factor;\n        var_inc *= inv_scale_factor; // Adjust the increment as well\n    }\n    \n    // Dynamically adjust the increment factor based on the solver's state and the variable's activity\n    // If the solver is struggling, increase the increment more aggressively\n    if (fast_lbd_sum > lbd_queue_size * 2 && activity[var] < 1e-5) {\n        var_inc *= (1 / 0.85); // More aggressive increment for less active variables when struggling\n    } else if (activity[var] > 1e5) {\n        var_inc *= 0.95; // Gently decrease the increment factor for highly active variables\n    } else {\n        var_inc *= (1 / 0.95); // Standard increment otherwise\n    }\n    \n    // Update the variable in the heap if it's there\n    if (vsids.inHeap(var)) vsids.update(var);\n}"
  },
  "11": {
    "time": 11402,
    "prompt": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n    \n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100; // Adjust the increment as well\n    }\n    \n    // Dynamically adjust the increment factor based on the solver's state\n    // If the average LBD of learned clauses is high, increase the increment more aggressively\n    double avg_lbd = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    if (avg_lbd > 5) {\n        var_inc *= (1 / 0.85); // More aggressive increment if the average LBD is high\n    } else {\n        var_inc *= (1 / 0.95); // Standard increment otherwise\n    }\n    \n    // Consider the phase of the variable for bumping\n    if (saved[var] == (activity[var] > 0 ? 1 : -1)) {\n        activity[var] += var_inc * coeff * 0.1; // Extra bump if the current phase aligns with the saved phase\n    }\n    \n    // Update the variable in the heap if it's there\n    if (vsids.inHeap(var)) vsids.update(var);\n}"
  },
  "9": {
    "time": 10633,
    "prompt": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n\n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        double inv_scale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= inv_scale_factor;\n        var_inc *= inv_scale_factor; // Adjust the increment as well\n    }\n\n    // Dynamically adjust the increment factor based on the solver's state and the coefficient\n    // If the coefficient is high, it means the variable is very active and we should increase the increment more aggressively\n    if (coeff > 0.2) {\n        var_inc *= (1 / 0.85); // More aggressive increment for highly active variables\n    } else if (coeff < 0.1) {\n        var_inc *= (1 / 0.99); // Less aggressive increment for less active variables\n    }\n\n    // Update the variable in the heap if it's there\n    // Only update the heap if the coefficient is significant to avoid unnecessary heap operations\n    if (coeff > 0.01 && vsids.inHeap(var)) vsids.update(var);\n}"
  },
  "13": {
    "time": 11402,
    "prompt": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n\n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        double inv_scale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= inv_scale_factor;\n        var_inc *= inv_scale_factor; // Adjust the increment as well\n    }\n\n    // Dynamically adjust the increment factor based on the solver's state and the coefficient\n    // If the coefficient is high, it means the variable is very active and we should increase the increment more aggressively\n    if (coeff > 0.2) {\n        var_inc *= (1 / 0.85); // More aggressive increment for highly active variables\n    } else if (coeff < 0.1) {\n        var_inc *= (1 / 0.99); // Less aggressive increment for less active variables\n    }\n\n    // Update the variable in the heap if it's there and the activity has increased significantly\n    if (coeff > 0.01 && vsids.inHeap(var)) {\n        vsids.update(var);\n    }\n}"
  },
  "14": {
    "time": 14091,
    "prompt": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n\n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        double inv_scale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= inv_scale_factor;\n        var_inc *= inv_scale_factor; // Adjust the increment as well\n    }\n\n    // Adjust the increment factor based on the solver's performance\n    // If the solver has had many conflicts, increase the increment more aggressively\n    if (conflicts > 100000 && coeff > 0.2) {\n        var_inc *= (1 / 0.75); // More aggressive increment for highly active variables in high conflict scenarios\n    } else if (conflicts < 1000 && coeff < 0.1) {\n        var_inc *= (1 / 1.01); // Less aggressive increment for less active variables in low conflict scenarios\n    }\n\n    // Update the variable in the heap if it's there\n    // Only update the heap if the activity change is significant to avoid unnecessary heap operations\n    if (activity[var] / (var_inc * coeff) < 2 && vsids.inHeap(var)) vsids.update(var);\n}"
  },
  "15": {
    "time": 11383,
    "prompt": "void Solver::bump_var(int var, double coeff) {\n    // Increase the activity by the increment multiplied by the coefficient\n    activity[var] += var_inc * coeff;\n\n    // Check if the activity is too large to prevent overflow\n    if (activity[var] > 1e100) {\n        // Normalize the activities\n        double inv_scale_factor = 1e-100;\n        for (int i = 1; i <= vars; i++) activity[i] *= inv_scale_factor;\n        var_inc *= inv_scale_factor; // Adjust the increment as well\n    }\n\n    // Adjust the increment factor based on the LBD of the clauses in which the variable appears\n    int min_lbd = INT_MAX;\n    for (auto& watcher : watch(var)) {\n        Clause& clause = clause_DB[watcher.idx_clause];\n        min_lbd = std::min(min_lbd, clause.lbd);\n    }\n    if (min_lbd < 5) {\n        var_inc *= (1 / 0.85); // More aggressive increment for variables in low LBD clauses\n    } else if (min_lbd > 10) {\n        var_inc *= (1 / 0.99); // Less aggressive increment for variables in high LBD clauses\n    }\n\n    // Update the variable in the heap if it's there and the activity increment is significant\n    if (coeff > 0.01 && vsids.inHeap(var)) vsids.update(var);\n}"
  }
}