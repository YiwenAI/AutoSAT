{
  "time": {
    "1": 38143,
    "3": 37587
  },
  "prompt": {
    "1": "void Solver::restart() {\n    // Reset LBD statistics\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root level\n    backtrack(0);\n    \n    // Introduce a more aggressive heuristic adjustment\n    var_inc *= 1e-3; // Increase the increment factor for variable activity\n    \n    // Diversified strategy for phase selection\n    for (int i = 1; i <= vars; i++) {\n        int phase_choice = rand() % 100;\n        if (phase_choice < 30) saved[i] = local_best[i]; // 30% chance to use the best local assignment\n        else if (phase_choice < 60) saved[i] = -local_best[i]; // 30% chance to use the inverse of the best local assignment\n        else if (phase_choice < 80) saved[i] = (rand() % 2) ? 1 : -1; // 20% chance for a random phase\n        else saved[i] = (value[i] == 0) ? ((rand() % 2) ? 1 : -1) : value[i]; // 20% chance to keep the current phase or random if unassigned\n    }\n}",
    "3": "void Solver::restart() {\n    // Reset LBD statistics\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root level\n    backtrack(0);\n    // Increase the variable increment to boost the activity of all variables\n    var_inc *= 1.5;\n    // Normalize the activity if it's too high to prevent overflow\n    if (var_inc > 1e100) {\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100;\n    }\n    // Update the phase of variables based on historical performance with a twist\n    for (int i = 1; i <= vars; i++) {\n        // If the variable has been historically good, flip its phase with a small probability to explore new branches\n        if (local_best[i] == saved[i]) {\n            saved[i] = (rand() % 10 < 2) ? -saved[i] : saved[i];\n        } else {\n            // If the variable has been historically bad, flip its phase\n            saved[i] = -local_best[i];\n        }\n    }\n}"
  }
}