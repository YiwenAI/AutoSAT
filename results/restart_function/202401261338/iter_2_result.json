{
  "time": {
    "10": 17222,
    "11": 18116,
    "12": 18369,
    "9": 19198
  },
  "prompt": {
    "10": "void Solver::rephase() {\n    rephases = 0;\n\n    // Dynamic adjustment based on the solver's progress\n    double progress_measure = double(conflicts) / (conflicts + restarts + 1);\n    threshold *= (0.8 + 0.2 * progress_measure);\n    rephase_limit += int(4096 * (1.0 - progress_measure));\n\n    // Heuristic updates\n    for (int i = 1; i <= vars; i++) {\n        // Flip polarity with a certain probability to diversify the search\n        if (rand() % 100 < 5) saved[i] = -saved[i];\n\n        // Randomize the polarity of a variable with a certain probability\n        if (rand() % 100 < 5) saved[i] = rand() % 2 ? 1 : -1;\n\n        // Bump the activity of variables that appear in recent conflict clauses\n        if (reason[i] != -1 && clause_DB[reason[i]].lbd < 3) bump_var(i, 1.1);\n    }\n\n    // Integration with other components\n    // If the solver is making good progress, increase the activity of variables that are not often involved in conflicts\n    if (progress_measure > 0.5) {\n        for (int i = 1; i <= vars; i++) {\n            if (reason[i] == -1 || clause_DB[reason[i]].lbd >= 3) bump_var(i, 0.8);\n        }\n    }\n}",
    "11": "void Solver::rephase() {\n    rephases = 0;\n\n    // Dynamic adjustment of the threshold and rephase limit based on solver's history and performance\n    double progress_ratio = double(conflicts) / (conflicts + restarts + 1);\n    threshold *= (0.8 + 0.2 * progress_ratio); // Adjust threshold based on progress\n    rephase_limit += int(8192 * (1.0 - progress_ratio)); // Adjust rephase limit inversely to progress\n\n    // Heuristic updates for variable polarities and activities\n    for (int i = 1; i <= vars; i++) {\n        // Flip polarity with a certain probability to diversify the search\n        if (rand() % 100 < 5) saved[i] = -saved[i];\n\n        // Randomize the polarity of a variable with a certain probability\n        if (rand() % 100 < 5) saved[i] = rand() % 2 ? 1 : -1;\n\n        // Bump the activity of variables that appear in recent conflict clauses with low LBD\n        if (reason[i] != -1 && clause_DB[reason[i]].lbd < 3) bump_var(i, 1.1);\n    }\n\n    // Integration with other components\n    // If the average LBD is high, indicating poor clause quality, perform a more aggressive rephasing\n    double avg_lbd = (conflicts > 0) ? (double)slow_lbd_sum / conflicts : 0;\n    if (avg_lbd > 4) {\n        for (int i = 1; i <= vars; i++) {\n            // Completely randomize the phases for a fresh start\n            saved[i] = rand() % 2 ? 1 : -1;\n            // Reset activity to a base level to reconsider all variables equally\n            activity[i] = 1.0;\n            if (vsids.inHeap(i)) vsids.update(i);\n        }\n    }\n}",
    "12": "void Solver::rephase() {\n    rephases = 0;\n\n    // Dynamically adjust the threshold and rephase limit based on the solver's progress\n    double progress_measure = double(conflicts) / (conflicts + restarts + 1);\n    threshold *= (0.8 + 0.2 * progress_measure);\n    rephase_limit += int(8192 * (1.0 - progress_measure));\n\n    // Heuristic updates\n    for (int i = 1; i <= vars; i++) {\n        // Flip polarity with a certain probability to diversify the search\n        if (rand() % 100 < 5) saved[i] = -saved[i];\n\n        // Randomize the polarity of a variable with a certain probability\n        if (rand() % 100 < 5) saved[i] = rand() % 2 ? 1 : -1;\n\n        // Bump the activity of variables that appear in recent conflict clauses\n        if (reason[i] != -1 && clause_DB[reason[i]].lbd <= 2) bump_var(i, 1.5);\n    }\n\n    // Integration with other components\n    // If the average LBD is high, indicating poor clause quality, perform a more conservative rephasing\n    double avg_lbd = (conflicts > 0) ? (double)slow_lbd_sum / conflicts : 0;\n    if (avg_lbd > 4) {\n        for (int i = 1; i <= vars; i++) {\n            // Slightly randomize the phases for a more conservative approach\n            if (rand() % 100 < 20) saved[i] = rand() % 2 ? 1 : -1;\n        }\n    }\n\n    // Adjust the variable increment based on the solver's progress\n    var_inc *= (progress_measure < 0.4) ? 1.1 : 0.9;\n}",
    "9": "void Solver::rephase() {\n    rephases = 0;\n    \n    // Dynamically adjust the threshold based on the solver's progress and the quality of clauses\n    double avg_lbd = (conflicts > 0) ? (double)slow_lbd_sum / conflicts : 0;\n    threshold *= (avg_lbd < 3) ? 0.85 : 1.05;\n\n    // Adjust the rephase limit based on the solver's progress\n    rephase_limit += (avg_lbd < 3) ? 16384 : 4096;\n\n    // Heuristic updates\n    for (int i = 1; i <= vars; i++) {\n        // Flip polarity with a certain probability to diversify the search\n        if (rand() % 100 < 5) saved[i] = -saved[i];\n\n        // Randomize the polarity of a variable with a certain probability\n        if (rand() % 100 < 5) saved[i] = rand() % 2 ? 1 : -1;\n\n        // Bump the activity of variables that appear in recent conflict clauses\n        if (reason[i] != -1 && clause_DB[reason[i]].lbd <= avg_lbd) bump_var(i, 1.5);\n    }\n\n    // Integration with other components\n    // If the average LBD is low, indicating good clause quality, perform a less aggressive rephasing\n    if (avg_lbd < 3) {\n        for (int i = 1; i <= vars; i++) {\n            // Slightly randomize the phases to avoid getting stuck in a local minimum\n            if (rand() % 100 < 5) saved[i] = rand() % 2 ? 1 : -1;\n        }\n    }\n}"
  }
}