{
  "time": {
    "5": 28470,
    "6": 33967,
    "7": 34982
  },
  "prompt": {
    "5": "void Solver::restart() {\n    // Reset LBD statistics\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root level\n    backtrack(0);\n    \n    // Adaptively adjust the variable increment based on the average LBD\n    double avg_lbd = slow_lbd_sum / (conflicts > 0 ? conflicts : 1);\n    var_inc = (avg_lbd < 2.0) ? var_inc * 1.1 : var_inc * 0.9;\n    \n    // Normalize the activity if it's too high to prevent overflow\n    if (var_inc > 1e100) {\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100;\n    }\n    \n    // Phase selection based on variable activity and historical performance\n    for (int i = 1; i <= vars; i++) {\n        if (activity[i] > 1e4) {\n            // For highly active variables, use the phase that led to the best local assignment\n            saved[i] = local_best[i];\n        } else {\n            // For less active variables, use a random phase to explore new possibilities\n            saved[i] = (rand() % 2) ? 1 : -1;\n        }\n    }\n}",
    "6": "void Solver::restart() {\n    // Reset LBD statistics\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root level\n    backtrack(0);\n    \n    // Dynamically adjust the variable increment based on the average LBD\n    double avg_lbd = slow_lbd_sum / (conflicts > 0 ? conflicts : 1);\n    var_inc = (avg_lbd < 2.0) ? var_inc * 1.1 : var_inc * 0.9;\n    \n    // Normalize the activity if it's too high to prevent overflow\n    if (var_inc > 1e100) {\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100;\n    }\n    \n    // Conservative phase selection with a random exploration element\n    for (int i = 1; i <= vars; i++) {\n        int phase_choice = rand() % 100;\n        if (phase_choice < 70) {\n            // 70% chance to keep the current phase or use the best local assignment if unassigned\n            saved[i] = (value[i] != 0) ? value[i] : local_best[i];\n        } else {\n            // 30% chance to flip the phase to explore new branches\n            saved[i] = (rand() % 2) ? 1 : -1;\n        }\n    }\n}",
    "7": "void Solver::restart() {\n    // Reset LBD statistics\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root level\n    backtrack(0);\n    \n    // Adaptive boosting of variable activity based on the number of conflicts\n    double multiplier = std::max(0.5, std::min(5.0, 1000.0 / (conflicts + 1)));\n    var_inc *= multiplier;\n    // Normalize the activity if it's too high to prevent overflow\n    if (var_inc > 1e100) {\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100;\n    }\n    \n    // More nuanced phase selection based on historical performance and current state\n    for (int i = 1; i <= vars; i++) {\n        // If the variable is currently assigned, we keep its phase with a high probability\n        if (value[i] != 0) {\n            saved[i] = (rand() % 100 < 90) ? value[i] : -value[i];\n        } else {\n            // For unassigned variables, we use a mix of historical best phase and random phase\n            int phase_rand = rand() % 100;\n            if (phase_rand < 50) saved[i] = local_best[i]; // 50% chance to use the best local assignment\n            else if (phase_rand < 75) saved[i] = -local_best[i]; // 25% chance to use the inverse of the best local assignment\n            else saved[i] = (rand() % 2) ? 1 : -1; // 25% chance for a random phase\n        }\n    }\n}"
  }
}