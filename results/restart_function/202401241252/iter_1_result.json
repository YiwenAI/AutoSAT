{"time": {"5": 20515, "6": 17651, "7": 20048, "8": 17972}, "prompt": {"5": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Rephasing step with a heuristic based on VSIDS activity and current phase\n    for (int i = 1; i <= vars; i++) {\n        // If the variable is highly active, consider flipping its phase\n        if (activity[i] > 1e4) {\n            saved[i] = -saved[i];\n        } else {\n            // Otherwise, keep the current phase or flip it with a small probability\n            int phase_rand = rand() % 100;\n            if (phase_rand < 10) saved[i] = -saved[i];\n        }\n    }\n}", "6": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Hybrid rephasing step\n    // Use a combination of the number of conflicts and randomness to decide the rephasing strategy\n    if (conflicts % 100 < 30) { // 30% of the time, use the best phase found so far\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    } else if (conflicts % 100 < 50) { // 20% of the time, invert the best phase\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    } else if (conflicts % 100 < 70) { // 20% of the time, set all phases to true\n        for (int i = 1; i <= vars; i++) saved[i] = 1;\n    } else if (conflicts % 100 < 90) { // 20% of the time, set all phases to false\n        for (int i = 1; i <= vars; i++) saved[i] = -1;\n    } else { // 10% of the time, randomize the phases\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}", "7": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Adaptive rephasing step based on the number of conflicts\n    // If the number of conflicts is high, increase the chance of phase inversion\n    int phase_change_frequency = std::max(1, 100 - conflicts / 1000); // Decrease frequency as conflicts increase\n    if (rand() % phase_change_frequency == 0) {\n        // Invert the phases of all variables\n        for (int i = 1; i <= vars; i++) saved[i] = -saved[i];\n    } else {\n        // Keep the same phase\n        for (int i = 1; i <= vars; i++) saved[i] = saved[i];\n    }\n}", "8": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Dynamic probabilistic rephasing based on LBD sums\n    double fast_avg_lbd = lbd_queue_size > 0 ? fast_lbd_sum / static_cast<double>(lbd_queue_size) : 0;\n    double slow_avg_lbd = conflicts > 0 ? slow_lbd_sum / static_cast<double>(conflicts) : 0;\n    double performance_ratio = fast_avg_lbd / (slow_avg_lbd + 1e-6); // Avoid division by zero\n\n    int phase_rand = rand() % 100;\n    if (performance_ratio < 1.0) { // Performance is good, prefer local_best\n        if ((phase_rand -= 70) < 0) for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else ;\n    } else { // Performance is not good, increase randomness\n        if ((phase_rand -= 50) < 0) for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 30) < 0) for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else ;\n    }\n}"}}