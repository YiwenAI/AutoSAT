{"time": {"13": 16695, "14": 18683, "15": 18207, "16": 20419}, "prompt": {"13": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Calculate the variance of the LBD scores from the fast LBD queue\n    double avg_lbd = lbd_queue_size > 0 ? fast_lbd_sum / static_cast<double>(lbd_queue_size) : 0;\n    double lbd_variance = 0;\n    for (int i = 0; i < lbd_queue_size; ++i) {\n        double diff = lbd_queue[i] - avg_lbd;\n        lbd_variance += diff * diff;\n    }\n    lbd_variance = lbd_queue_size > 1 ? lbd_variance / (lbd_queue_size - 1) : 0;\n    \n    // Use the variance to adjust the rephasing probabilities\n    int phase_rand = rand() % 100;\n    if (lbd_variance < 1.0) { // Low variance, the solver might be stuck, increase randomness\n        if ((phase_rand -= 50) < 0) for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    } else { // High variance, the solver is exploring, stick to the best phases\n        if ((phase_rand -= 80) < 0) for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n}", "14": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Calculate the average LBD from the fast LBD queue\n    double avg_lbd = lbd_queue_size > 0 ? fast_lbd_sum / static_cast<double>(lbd_queue_size) : 0;\n    \n    // Calculate the average activity of variables\n    double avg_activity = 0;\n    for (int i = 1; i <= vars; i++) {\n        avg_activity += activity[i];\n    }\n    avg_activity /= vars;\n    \n    // Use the average LBD and average activity to adjust the rephasing probabilities\n    for (int i = 1; i <= vars; i++) {\n        int phase_rand = rand() % 100;\n        double activity_factor = activity[i] / avg_activity;\n        \n        if (avg_lbd < 2.0 && activity_factor > 1.0) { // Good performance and high activity\n            if ((phase_rand -= 80) < 0) saved[i] = local_best[i]; // Keep the best phase with high probability\n            else saved[i] = rand() % 2 ? 1 : -1; // Randomize with low probability\n        } else if (avg_lbd >= 2.0 || activity_factor <= 1.0) { // Poor performance or low activity\n            if ((phase_rand -= 50) < 0) saved[i] = -local_best[i]; // Invert the best phase with higher probability\n            else saved[i] = rand() % 2 ? 1 : -1; // Randomize with lower probability\n        }\n        \n        // Apply a decay to the activity to reduce the influence of older activities\n        activity[i] *= 0.95;\n    }\n}", "15": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Calculate the average LBD from the fast LBD queue\n    double avg_lbd = lbd_queue_size > 0 ? fast_lbd_sum / static_cast<double>(lbd_queue_size) : 0;\n    \n    // Dynamically adjust the threshold for the average LBD based on historical performance\n    double dynamic_lbd_threshold = std::max(2.0, slow_lbd_sum / static_cast<double>(conflicts) * 1.1);\n    \n    // Use the average LBD and dynamic threshold to adjust the rephasing probabilities\n    int phase_rand = rand() % 100;\n    if (avg_lbd < dynamic_lbd_threshold) { // If the average LBD is below the dynamic threshold, the solver is performing well, so stick to the best phases\n        if ((phase_rand -= 70) < 0) for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 20) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    } else { // If the average LBD is above the dynamic threshold, the solver is performing poorly, so increase randomness\n        if ((phase_rand -= 40) < 0) for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 40) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n    \n    // Introduce a decay factor for the variable activity to give more weight to recent conflicts\n    for (int i = 1; i <= vars; i++) {\n        activity[i] *= 0.95;\n    }\n}", "16": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Calculate the average LBD from the fast LBD queue\n    double avg_lbd = lbd_queue_size > 0 ? fast_lbd_sum / static_cast<double>(lbd_queue_size) : 0;\n    \n    // Adjust the rephasing strategy based on the average LBD and the number of conflicts\n    for (int i = 1; i <= vars; i++) {\n        // Use a dynamic threshold based on the number of conflicts to adjust the rephasing\n        double dynamic_threshold = conflicts / 10000.0;\n        double activity_factor = activity[i] / (1.0 + var_inc); // Normalize activity by the increment factor\n        \n        if (avg_lbd < 2.0) { // If the average LBD is low, the solver is performing well\n            // Keep the best phase for highly active variables\n            saved[i] = activity_factor > dynamic_threshold ? local_best[i] : (rand() % 2 ? 1 : -1);\n        } else { // If the average LBD is high, the solver is performing poorly\n            // Increase randomness for highly active variables\n            saved[i] = activity_factor > dynamic_threshold ? (rand() % 2 ? 1 : -1) : local_best[i];\n        }\n    }\n}"}}