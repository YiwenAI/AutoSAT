{
  "0": {
    "time": 16424,
    "prompt": " "
  },
  "1": {
    "time": 18516,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Rephasing step with a different heuristic\n    // Instead of random rephasing, we use a deterministic approach based on the number of conflicts\n    if (conflicts % 2 == 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = (conflicts / 2) % 2 ? 1 : -1; // Alternate between true and false\n    } else {\n        for (int i = 1; i <= vars; i++) saved[i] = (i % 2) ? 1 : -1; // Alternate based on variable index\n    }\n}"
  },
  "2": {
    "time": 18240,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Rephasing step with a different heuristic\n    // Instead of random rephasing, we use a deterministic approach based on the number of conflicts\n    if (conflicts % 3 == 0) {\n        // Invert the phases of all variables\n        for (int i = 1; i <= vars; i++) saved[i] = -saved[i];\n    } else if (conflicts % 3 == 1) {\n        // Set all phases to true\n        for (int i = 1; i <= vars; i++) saved[i] = 1;\n    } else {\n        // Set all phases to false\n        for (int i = 1; i <= vars; i++) saved[i] = -1;\n    }\n}"
  },
  "3": {
    "time": 20441,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n\n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n\n    // Perform a rephasing step with a different heuristic\n    // Here we use a deterministic approach instead of a probabilistic one\n    // We cycle through three phases: using the last phase, inverting the last phase, and setting a random phase\n    static int phase_selector = 0;\n    phase_selector = (phase_selector + 1) % 3;\n    switch (phase_selector) {\n        case 0: // Use the last saved phase\n            for (int i = 1; i <= vars; i++) saved[i] = saved[i];\n            break;\n        case 1: // Invert the last saved phase\n            for (int i = 1; i <= vars; i++) saved[i] = -saved[i];\n            break;\n        case 2: // Set a random phase\n            for (int i = 1; i <= vars; i++) saved[i] = (rand() % 2) * 2 - 1;\n            break;\n    }\n}"
  },
  "5": {
    "time": 20515,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Rephasing step with a heuristic based on VSIDS activity and current phase\n    for (int i = 1; i <= vars; i++) {\n        // If the variable is highly active, consider flipping its phase\n        if (activity[i] > 1e4) {\n            saved[i] = -saved[i];\n        } else {\n            // Otherwise, keep the current phase or flip it with a small probability\n            int phase_rand = rand() % 100;\n            if (phase_rand < 10) saved[i] = -saved[i];\n        }\n    }\n}"
  },
  "6": {
    "time": 17651,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Hybrid rephasing step\n    // Use a combination of the number of conflicts and randomness to decide the rephasing strategy\n    if (conflicts % 100 < 30) { // 30% of the time, use the best phase found so far\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    } else if (conflicts % 100 < 50) { // 20% of the time, invert the best phase\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    } else if (conflicts % 100 < 70) { // 20% of the time, set all phases to true\n        for (int i = 1; i <= vars; i++) saved[i] = 1;\n    } else if (conflicts % 100 < 90) { // 20% of the time, set all phases to false\n        for (int i = 1; i <= vars; i++) saved[i] = -1;\n    } else { // 10% of the time, randomize the phases\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}"
  },
  "7": {
    "time": 20048,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Adaptive rephasing step based on the number of conflicts\n    // If the number of conflicts is high, increase the chance of phase inversion\n    int phase_change_frequency = std::max(1, 100 - conflicts / 1000); // Decrease frequency as conflicts increase\n    if (rand() % phase_change_frequency == 0) {\n        // Invert the phases of all variables\n        for (int i = 1; i <= vars; i++) saved[i] = -saved[i];\n    } else {\n        // Keep the same phase\n        for (int i = 1; i <= vars; i++) saved[i] = saved[i];\n    }\n}"
  },
  "8": {
    "time": 17972,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Dynamic probabilistic rephasing based on LBD sums\n    double fast_avg_lbd = lbd_queue_size > 0 ? fast_lbd_sum / static_cast<double>(lbd_queue_size) : 0;\n    double slow_avg_lbd = conflicts > 0 ? slow_lbd_sum / static_cast<double>(conflicts) : 0;\n    double performance_ratio = fast_avg_lbd / (slow_avg_lbd + 1e-6); // Avoid division by zero\n\n    int phase_rand = rand() % 100;\n    if (performance_ratio < 1.0) { // Performance is good, prefer local_best\n        if ((phase_rand -= 70) < 0) for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else ;\n    } else { // Performance is not good, increase randomness\n        if ((phase_rand -= 50) < 0) for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 30) < 0) for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else ;\n    }\n}"
  },
  "10": {
    "time": 19764,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Enhanced hybrid rephasing step\n    // Use a combination of the number of conflicts, variable activity, and randomness to decide the rephasing strategy\n    double activity_threshold = 1e4; // Threshold for considering a variable highly active\n    for (int i = 1; i <= vars; i++) {\n        int phase_rand = rand() % 100;\n        if (activity[i] > activity_threshold) { // For highly active variables, flip the phase with higher probability\n            if (phase_rand < 80) saved[i] = -local_best[i]; // 80% chance to flip the phase\n            else saved[i] = local_best[i]; // 20% chance to keep the phase\n        } else { // For less active variables, use the previous hybrid approach\n            if (conflicts % 100 < 25) { // 25% of the time, use the best phase found so far\n                saved[i] = local_best[i];\n            } else if (conflicts % 100 < 45) { // 20% of the time, invert the best phase\n                saved[i] = -local_best[i];\n            } else if (conflicts % 100 < 65) { // 20% of the time, set all phases to true\n                saved[i] = 1;\n            } else if (conflicts % 100 < 85) { // 20% of the time, set all phases to false\n                saved[i] = -1;\n            } else { // 15% of the time, randomize the phases\n                saved[i] = rand() % 2 ? 1 : -1;\n            }\n        }\n    }\n}"
  },
  "11": {
    "time": 17106,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Calculate the average LBD from the fast LBD queue\n    double avg_lbd = lbd_queue_size > 0 ? fast_lbd_sum / static_cast<double>(lbd_queue_size) : 0;\n    \n    // Use the average LBD to adjust the rephasing probabilities\n    int phase_rand = rand() % 100;\n    if (avg_lbd < 2.0) { // If the average LBD is low, the solver is performing well, so stick to the best phases\n        if ((phase_rand -= 70) < 0) for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 20) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    } else { // If the average LBD is high, the solver is performing poorly, so increase randomness\n        if ((phase_rand -= 40) < 0) for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 40) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}"
  },
  "9": {
    "time": 18799,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Enhanced hybrid rephasing step\n    // Use a combination of variable activity, the number of conflicts, and randomness to decide the rephasing strategy\n    for (int i = 1; i <= vars; i++) {\n        // Calculate a heuristic value based on activity and conflicts\n        double heuristic = activity[i] / (1.0 + conflicts);\n        \n        // Decide the rephasing strategy based on the heuristic value\n        if (heuristic > 0.5) {\n            // High activity relative to conflicts, keep the best phase\n            saved[i] = local_best[i];\n        } else if (heuristic > 0.1) {\n            // Medium activity, invert the best phase with a 50% chance\n            saved[i] = (rand() % 2) ? -local_best[i] : local_best[i];\n        } else {\n            // Low activity, randomize the phase with a higher probability\n            saved[i] = (rand() % 100 < 80) ? (rand() % 2 ? 1 : -1) : local_best[i];\n        }\n    }\n}"
  },
  "13": {
    "time": 16695,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Calculate the variance of the LBD scores from the fast LBD queue\n    double avg_lbd = lbd_queue_size > 0 ? fast_lbd_sum / static_cast<double>(lbd_queue_size) : 0;\n    double lbd_variance = 0;\n    for (int i = 0; i < lbd_queue_size; ++i) {\n        double diff = lbd_queue[i] - avg_lbd;\n        lbd_variance += diff * diff;\n    }\n    lbd_variance = lbd_queue_size > 1 ? lbd_variance / (lbd_queue_size - 1) : 0;\n    \n    // Use the variance to adjust the rephasing probabilities\n    int phase_rand = rand() % 100;\n    if (lbd_variance < 1.0) { // Low variance, the solver might be stuck, increase randomness\n        if ((phase_rand -= 50) < 0) for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    } else { // High variance, the solver is exploring, stick to the best phases\n        if ((phase_rand -= 80) < 0) for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n}"
  },
  "14": {
    "time": 18683,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Calculate the average LBD from the fast LBD queue\n    double avg_lbd = lbd_queue_size > 0 ? fast_lbd_sum / static_cast<double>(lbd_queue_size) : 0;\n    \n    // Calculate the average activity of variables\n    double avg_activity = 0;\n    for (int i = 1; i <= vars; i++) {\n        avg_activity += activity[i];\n    }\n    avg_activity /= vars;\n    \n    // Use the average LBD and average activity to adjust the rephasing probabilities\n    for (int i = 1; i <= vars; i++) {\n        int phase_rand = rand() % 100;\n        double activity_factor = activity[i] / avg_activity;\n        \n        if (avg_lbd < 2.0 && activity_factor > 1.0) { // Good performance and high activity\n            if ((phase_rand -= 80) < 0) saved[i] = local_best[i]; // Keep the best phase with high probability\n            else saved[i] = rand() % 2 ? 1 : -1; // Randomize with low probability\n        } else if (avg_lbd >= 2.0 || activity_factor <= 1.0) { // Poor performance or low activity\n            if ((phase_rand -= 50) < 0) saved[i] = -local_best[i]; // Invert the best phase with higher probability\n            else saved[i] = rand() % 2 ? 1 : -1; // Randomize with lower probability\n        }\n        \n        // Apply a decay to the activity to reduce the influence of older activities\n        activity[i] *= 0.95;\n    }\n}"
  },
  "15": {
    "time": 18207,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Calculate the average LBD from the fast LBD queue\n    double avg_lbd = lbd_queue_size > 0 ? fast_lbd_sum / static_cast<double>(lbd_queue_size) : 0;\n    \n    // Dynamically adjust the threshold for the average LBD based on historical performance\n    double dynamic_lbd_threshold = std::max(2.0, slow_lbd_sum / static_cast<double>(conflicts) * 1.1);\n    \n    // Use the average LBD and dynamic threshold to adjust the rephasing probabilities\n    int phase_rand = rand() % 100;\n    if (avg_lbd < dynamic_lbd_threshold) { // If the average LBD is below the dynamic threshold, the solver is performing well, so stick to the best phases\n        if ((phase_rand -= 70) < 0) for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 20) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    } else { // If the average LBD is above the dynamic threshold, the solver is performing poorly, so increase randomness\n        if ((phase_rand -= 40) < 0) for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 40) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n    \n    // Introduce a decay factor for the variable activity to give more weight to recent conflicts\n    for (int i = 1; i <= vars; i++) {\n        activity[i] *= 0.95;\n    }\n}"
  },
  "16": {
    "time": 20419,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Calculate the average LBD from the fast LBD queue\n    double avg_lbd = lbd_queue_size > 0 ? fast_lbd_sum / static_cast<double>(lbd_queue_size) : 0;\n    \n    // Adjust the rephasing strategy based on the average LBD and the number of conflicts\n    for (int i = 1; i <= vars; i++) {\n        // Use a dynamic threshold based on the number of conflicts to adjust the rephasing\n        double dynamic_threshold = conflicts / 10000.0;\n        double activity_factor = activity[i] / (1.0 + var_inc); // Normalize activity by the increment factor\n        \n        if (avg_lbd < 2.0) { // If the average LBD is low, the solver is performing well\n            // Keep the best phase for highly active variables\n            saved[i] = activity_factor > dynamic_threshold ? local_best[i] : (rand() % 2 ? 1 : -1);\n        } else { // If the average LBD is high, the solver is performing poorly\n            // Increase randomness for highly active variables\n            saved[i] = activity_factor > dynamic_threshold ? (rand() % 2 ? 1 : -1) : local_best[i];\n        }\n    }\n}"
  }
}