{"time": {"10": 19764, "11": 17106, "9": 18799}, "prompt": {"10": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Enhanced hybrid rephasing step\n    // Use a combination of the number of conflicts, variable activity, and randomness to decide the rephasing strategy\n    double activity_threshold = 1e4; // Threshold for considering a variable highly active\n    for (int i = 1; i <= vars; i++) {\n        int phase_rand = rand() % 100;\n        if (activity[i] > activity_threshold) { // For highly active variables, flip the phase with higher probability\n            if (phase_rand < 80) saved[i] = -local_best[i]; // 80% chance to flip the phase\n            else saved[i] = local_best[i]; // 20% chance to keep the phase\n        } else { // For less active variables, use the previous hybrid approach\n            if (conflicts % 100 < 25) { // 25% of the time, use the best phase found so far\n                saved[i] = local_best[i];\n            } else if (conflicts % 100 < 45) { // 20% of the time, invert the best phase\n                saved[i] = -local_best[i];\n            } else if (conflicts % 100 < 65) { // 20% of the time, set all phases to true\n                saved[i] = 1;\n            } else if (conflicts % 100 < 85) { // 20% of the time, set all phases to false\n                saved[i] = -1;\n            } else { // 15% of the time, randomize the phases\n                saved[i] = rand() % 2 ? 1 : -1;\n            }\n        }\n    }\n}", "11": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Calculate the average LBD from the fast LBD queue\n    double avg_lbd = lbd_queue_size > 0 ? fast_lbd_sum / static_cast<double>(lbd_queue_size) : 0;\n    \n    // Use the average LBD to adjust the rephasing probabilities\n    int phase_rand = rand() % 100;\n    if (avg_lbd < 2.0) { // If the average LBD is low, the solver is performing well, so stick to the best phases\n        if ((phase_rand -= 70) < 0) for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 20) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    } else { // If the average LBD is high, the solver is performing poorly, so increase randomness\n        if ((phase_rand -= 40) < 0) for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 40) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}", "9": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    \n    // Backtrack to the root of the search tree (decision level 0)\n    backtrack(0);\n    \n    // Enhanced hybrid rephasing step\n    // Use a combination of variable activity, the number of conflicts, and randomness to decide the rephasing strategy\n    for (int i = 1; i <= vars; i++) {\n        // Calculate a heuristic value based on activity and conflicts\n        double heuristic = activity[i] / (1.0 + conflicts);\n        \n        // Decide the rephasing strategy based on the heuristic value\n        if (heuristic > 0.5) {\n            // High activity relative to conflicts, keep the best phase\n            saved[i] = local_best[i];\n        } else if (heuristic > 0.1) {\n            // Medium activity, invert the best phase with a 50% chance\n            saved[i] = (rand() % 2) ? -local_best[i] : local_best[i];\n        } else {\n            // Low activity, randomize the phase with a higher probability\n            saved[i] = (rand() % 100 < 80) ? (rand() % 2 ? 1 : -1) : local_best[i];\n        }\n    }\n}"}}