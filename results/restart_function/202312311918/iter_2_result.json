{"time": {"9": 881.5}, "prompt": {"9": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Probabilistic rephasing based on different criteria and solver's state\n    int phase_rand = rand() % 100;\n    // Calculate the moving average of the LBDs for fast and slow windows\n    double fast_lbd_avg = lbd_queue_size > 0 ? fast_lbd_sum / (double)lbd_queue_size : 0;\n    double slow_lbd_avg = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    \n    // Strategy 1: With a probability of 35%, use the current best phases if fast LBD average is better than slow LBD average\n    if (fast_lbd_avg < slow_lbd_avg && (phase_rand -= 35) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 25%, invert the current best phases if fast LBD average is not improving\n    else if (fast_lbd_avg >= slow_lbd_avg && (phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 20%, rephase based on variable activity and LBD values\n    else if ((phase_rand -= 20) < 0) {\n        for (int i = 1; i <= vars; i++) {\n            saved[i] = (activity[i] > 1e4 || (fast_lbd_avg > 2.5 && slow_lbd_avg > 2.5)) ? -saved[i] : saved[i];\n        }\n    }\n    // Strategy 4: With a probability of 20%, rephase randomly to introduce more diversity\n    else {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}"}}