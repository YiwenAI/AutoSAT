{
  "0": {
    "time": 915.25,
    "prompt": "else if (lbd_queue_size == 50 && 0.8 * fast_lbd_sum / lbd_queue_size > slow_lbd_sum / conflicts) restart();"
  },
  "1": {
    "time": 1131.5,
    "prompt": "void Solver::restart() {\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    backtrack(0);\n\n    // Use a different strategy for probabilistic rephasing\n    int phase_rand = rand() % 100;\n    if ((phase_rand -= 50) < 0)     for (int i = 1; i <= vars; i++) saved[i] = (rand() % 2) ? local_best[i] : -local_best[i]; // Mix of best and inverted best\n    else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = (i % 2) ? 1 : -1; // Alternating phase\n    else if ((phase_rand -= 20) < 0) for (int i = 1; i <= vars; i++) saved[i] = (rand() % 2) ? value[i] : -value[i]; // Mix of current and inverted current\n    else for (int i = 1; i <= vars; i++) saved[i] = (rand() % 3) - 1; // Random phase with possible unset\n}"
  },
  "2": {
    "time": 966.25,
    "prompt": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Probabilistic rephasing based on different criteria\n    int phase_rand = rand() % 100;\n    \n    // Strategy 1: With a probability of 50%, use the current best phases\n    if ((phase_rand -= 50) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 20%, invert the current best phases\n    else if ((phase_rand -= 20) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 15%, rephase randomly\n    else if ((phase_rand -= 15) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n    // Strategy 4: With a probability of 15%, keep the phases as they are\n    // This is the implicit else case where no action is taken\n}"
  },
  "4": {
    "time": 1045.75,
    "prompt": "void Solver::restart() {\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    backtrack(0);\n    int phase_rand = rand() % 100; // probabilistic rephasing\n\n    // Enhanced diversification strategy\n    if ((phase_rand -= 50) < 0) {\n        // Flip the phases of all variables\n        for (int i = 1; i <= vars; i++) saved[i] = -saved[i];\n    } else if ((phase_rand -= 30) < 0) {\n        // Randomly select a subset of variables and flip their phases\n        for (int i = 1; i <= vars; i++) {\n            if (rand() % 2) saved[i] = -saved[i];\n        }\n    } else if ((phase_rand -= 10) < 0) {\n        // Set all phases to the value that occurs least frequently in the trail\n        int positive_count = 0;\n        for (int i = 0; i < trail.size(); i++) {\n            if (trail[i] > 0) positive_count++;\n        }\n        int desired_phase = (positive_count > trail.size() / 2) ? -1 : 1;\n        for (int i = 1; i <= vars; i++) saved[i] = desired_phase;\n    } else {\n        // Keep the current phases\n    }\n}"
  },
  "7": {
    "time": 1040.75,
    "prompt": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    \n    // Adaptive strategy based on solver's performance\n    int phase_rand = rand() % 100;\n    double fast_lbd_avg = fast_lbd_sum / (double)lbd_queue_size;\n    double slow_lbd_avg = slow_lbd_sum / (double)conflicts;\n    \n    // Strategy 1: With a probability of 40%, use the current best phases if fast LBD average is promising\n    if (fast_lbd_avg < slow_lbd_avg && (phase_rand -= 40) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 30%, invert the current best phases if stuck in a local optimum\n    else if (fast_lbd_avg >= slow_lbd_avg && (phase_rand -= 30) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 15%, rephase randomly to introduce diversity\n    else if ((phase_rand -= 15) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n    // Strategy 4: With a probability of 15%, keep the phases as they are to exploit the current search space\n    // This is the implicit else case where no action is taken\n}"
  },
  "8": {
    "time": 951.25,
    "prompt": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Probabilistic rephasing based on different criteria and solver's state\n    int phase_rand = rand() % 100;\n    double avg_lbd = (conflicts > 0) ? (double)slow_lbd_sum / conflicts : 0;\n    \n    // Strategy 1: With a probability of 40%, use the current best phases if average LBD is low\n    if ((phase_rand -= 40) < 0 && avg_lbd < 3.0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 30%, invert the current best phases if average LBD is high\n    else if ((phase_rand -= 30) < 0 && avg_lbd >= 3.0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 15%, rephase based on variable activity\n    else if ((phase_rand -= 15) < 0) {\n        for (int i = 1; i <= vars; i++) {\n            saved[i] = (activity[i] > 1e4) ? -saved[i] : saved[i];\n        }\n    }\n    // Strategy 4: With a probability of 15%, rephase randomly\n    else {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}"
  },
  "9": {
    "time": 881.5,
    "prompt": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Probabilistic rephasing based on different criteria and solver's state\n    int phase_rand = rand() % 100;\n    // Calculate the moving average of the LBDs for fast and slow windows\n    double fast_lbd_avg = lbd_queue_size > 0 ? fast_lbd_sum / (double)lbd_queue_size : 0;\n    double slow_lbd_avg = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    \n    // Strategy 1: With a probability of 35%, use the current best phases if fast LBD average is better than slow LBD average\n    if (fast_lbd_avg < slow_lbd_avg && (phase_rand -= 35) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 25%, invert the current best phases if fast LBD average is not improving\n    else if (fast_lbd_avg >= slow_lbd_avg && (phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 20%, rephase based on variable activity and LBD values\n    else if ((phase_rand -= 20) < 0) {\n        for (int i = 1; i <= vars; i++) {\n            saved[i] = (activity[i] > 1e4 || (fast_lbd_avg > 2.5 && slow_lbd_avg > 2.5)) ? -saved[i] : saved[i];\n        }\n    }\n    // Strategy 4: With a probability of 20%, rephase randomly to introduce more diversity\n    else {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}"
  },
  "13": {
    "time": 906.0,
    "prompt": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Probabilistic rephasing based on different criteria and solver's state\n    int phase_rand = rand() % 100;\n    // Calculate the moving average of the LBDs for fast and slow windows\n    double fast_lbd_avg = lbd_queue_size > 0 ? fast_lbd_sum / (double)lbd_queue_size : 0;\n    double slow_lbd_avg = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    // Calculate the variance of the LBDs in the fast window\n    double lbd_variance = 0;\n    if (lbd_queue_size > 1) {\n        double lbd_mean = fast_lbd_sum / (double)lbd_queue_size;\n        for (int i = 0; i < lbd_queue_size; ++i) {\n            lbd_variance += (lbd_queue[i] - lbd_mean) * (lbd_queue[i] - lbd_mean);\n        }\n        lbd_variance /= lbd_queue_size;\n    }\n\n    // Strategy 1: With a probability of 30%, use the current best phases if fast LBD average is better than slow LBD average and variance is low\n    if (fast_lbd_avg < slow_lbd_avg && lbd_variance < 0.5 && (phase_rand -= 30) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 25%, invert the current best phases if fast LBD average is not improving or variance is high\n    else if ((fast_lbd_avg >= slow_lbd_avg || lbd_variance >= 0.5) && (phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 20%, rephase based on variable activity and LBD values\n    else if ((phase_rand -= 20) < 0) {\n        for (int i = 1; i <= vars; i++) {\n            saved[i] = (activity[i] > 1e4 || (fast_lbd_avg > 2.5 && slow_lbd_avg > 2.5)) ? -saved[i] : saved[i];\n        }\n    }\n    // Strategy 4: With a probability of 25%, rephase randomly to introduce more diversity\n    else {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}"
  },
  "15": {
    "time": 1033.75,
    "prompt": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Probabilistic rephasing based on different criteria and solver's state\n    int phase_rand = rand() % 100;\n    // Calculate the moving average of the LBDs for fast and slow windows\n    double fast_lbd_avg = lbd_queue_size > 0 ? fast_lbd_sum / (double)lbd_queue_size : 0;\n    double slow_lbd_avg = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    // Calculate the trend of the LBD values over recent conflicts\n    double lbd_trend = lbd_queue_size >= 2 ? (lbd_queue[lbd_queue_pos == 0 ? 49 : lbd_queue_pos - 1] - lbd_queue[(lbd_queue_pos + 49) % 50]) / 2.0 : 0;\n    // Adaptive threshold based on the solver's progress\n    double adaptive_threshold = 1.0 + 0.01 * conflicts;\n\n    // Strategy 1: With a probability of 35%, use the current best phases if LBD trend is negative (improving)\n    if (lbd_trend < 0 && (phase_rand -= 35) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 25%, invert the current best phases if LBD average is not improving and trend is not negative\n    else if (fast_lbd_avg >= slow_lbd_avg && lbd_trend >= 0 && (phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 20%, rephase based on variable activity, LBD values, and adaptive threshold\n    else if ((phase_rand -= 20) < 0) {\n        for (int i = 1; i <= vars; i++) {\n            saved[i] = (activity[i] > adaptive_threshold || (fast_lbd_avg > 2.5 && slow_lbd_avg > 2.5)) ? -saved[i] : saved[i];\n        }\n    }\n    // Strategy 4: With a probability of 20%, rephase randomly to introduce more diversity\n    else {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}"
  },
  "17": {
    "time": 1027.5,
    "prompt": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Probabilistic rephasing based on different criteria and solver's state\n    int phase_rand = rand() % 100;\n    // Calculate the moving average of the LBDs for fast and slow windows\n    double fast_lbd_avg = lbd_queue_size > 0 ? fast_lbd_sum / (double)lbd_queue_size : 0;\n    double slow_lbd_avg = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    // Calculate the exponential moving average (EMA) of the LBDs for the fast window\n    double lbd_ema = 0;\n    double alpha = 0.1; // Smoothing factor\n    for (int i = 0; i < lbd_queue_size; ++i) {\n        lbd_ema = alpha * lbd_queue[i] + (1 - alpha) * lbd_ema;\n    }\n\n    // Strategy 1: With a probability of 25%, use the current best phases if fast LBD EMA is better than slow LBD average\n    if (lbd_ema < slow_lbd_avg && (phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 25%, invert the current best phases if fast LBD EMA is not improving\n    else if (lbd_ema >= slow_lbd_avg && (phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 25%, rephase based on variable activity and LBD EMA\n    else if ((phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) {\n            saved[i] = (activity[i] > 1e4 || lbd_ema > 2.5) ? -saved[i] : saved[i];\n        }\n    }\n    // Strategy 4: With a probability of 25%, rephase randomly to introduce more diversity\n    else {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}"
  },
  "19": {
    "time": 863.5,
    "prompt": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Probabilistic rephasing based on different criteria and solver's state\n    int phase_rand = rand() % 100;\n    // Calculate the moving average of the LBDs for fast and slow windows\n    double fast_lbd_avg = lbd_queue_size > 0 ? fast_lbd_sum / (double)lbd_queue_size : 0;\n    double slow_lbd_avg = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    // Introduce a new heuristic based on the ratio of fast/slow LBD averages\n    double lbd_ratio = slow_lbd_avg > 0 ? fast_lbd_avg / slow_lbd_avg : 0;\n\n    // Strategy 1: With a probability of 30%, use the current best phases if the LBD ratio is below a threshold, indicating improvement\n    if (lbd_ratio < 0.8 && (phase_rand -= 30) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 25%, invert the current best phases if the LBD ratio is above a threshold, indicating stagnation\n    else if (lbd_ratio >= 0.8 && (phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 15%, rephase based on variable activity and a dynamic threshold that adapts to the number of conflicts\n    else if ((phase_rand -= 15) < 0) {\n        double dynamic_threshold = 1e4 * (1.0 + 0.001 * conflicts);\n        for (int i = 1; i <= vars; i++) {\n            saved[i] = (activity[i] > dynamic_threshold) ? -saved[i] : saved[i];\n        }\n    }\n    // Strategy 4: With a probability of 30%, rephase randomly to introduce more diversity, especially when other strategies are not effective\n    else {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}"
  },
  "20": {
    "time": 932.5,
    "prompt": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Probabilistic rephasing based on different criteria and solver's state\n    int phase_rand = rand() % 100;\n    // Calculate the moving average of the LBDs for fast and slow windows\n    double fast_lbd_avg = lbd_queue_size > 0 ? fast_lbd_sum / (double)lbd_queue_size : 0;\n    double slow_lbd_avg = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    // Calculate the variance of the LBDs in the fast window\n    double lbd_variance = 0;\n    if (lbd_queue_size > 1) {\n        double lbd_mean = fast_lbd_sum / (double)lbd_queue_size;\n        for (int i = 0; i < lbd_queue_size; ++i) {\n            lbd_variance += (lbd_queue[i] - lbd_mean) * (lbd_queue[i] - lbd_mean);\n        }\n        lbd_variance /= lbd_queue_size;\n    }\n\n    // Strategy 1: With a probability of 30%, use the current best phases if fast LBD average is better than slow LBD average and variance is low\n    if (fast_lbd_avg < slow_lbd_avg && lbd_variance < 0.5 && (phase_rand -= 30) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 25%, invert the current best phases if fast LBD average is not improving or variance is high\n    else if ((fast_lbd_avg >= slow_lbd_avg || lbd_variance >= 0.5) && (phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 20%, rephase based on variable activity and LBD values\n    else if ((phase_rand -= 20) < 0) {\n        for (int i = 1; i <= vars; i++) {\n            saved[i] = (activity[i] > 1e4 || (fast_lbd_avg > 2.5 && slow_lbd_avg > 2.5)) ? -saved[i] : saved[i];\n        }\n    }\n    // Strategy 4: With a probability of 25%, rephase randomly to introduce more diversity\n    else {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}"
  }
}