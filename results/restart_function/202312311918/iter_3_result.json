{"time": {"13": 906.0, "15": 1033.75}, "prompt": {"13": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Probabilistic rephasing based on different criteria and solver's state\n    int phase_rand = rand() % 100;\n    // Calculate the moving average of the LBDs for fast and slow windows\n    double fast_lbd_avg = lbd_queue_size > 0 ? fast_lbd_sum / (double)lbd_queue_size : 0;\n    double slow_lbd_avg = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    // Calculate the variance of the LBDs in the fast window\n    double lbd_variance = 0;\n    if (lbd_queue_size > 1) {\n        double lbd_mean = fast_lbd_sum / (double)lbd_queue_size;\n        for (int i = 0; i < lbd_queue_size; ++i) {\n            lbd_variance += (lbd_queue[i] - lbd_mean) * (lbd_queue[i] - lbd_mean);\n        }\n        lbd_variance /= lbd_queue_size;\n    }\n\n    // Strategy 1: With a probability of 30%, use the current best phases if fast LBD average is better than slow LBD average and variance is low\n    if (fast_lbd_avg < slow_lbd_avg && lbd_variance < 0.5 && (phase_rand -= 30) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 25%, invert the current best phases if fast LBD average is not improving or variance is high\n    else if ((fast_lbd_avg >= slow_lbd_avg || lbd_variance >= 0.5) && (phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 20%, rephase based on variable activity and LBD values\n    else if ((phase_rand -= 20) < 0) {\n        for (int i = 1; i <= vars; i++) {\n            saved[i] = (activity[i] > 1e4 || (fast_lbd_avg > 2.5 && slow_lbd_avg > 2.5)) ? -saved[i] : saved[i];\n        }\n    }\n    // Strategy 4: With a probability of 25%, rephase randomly to introduce more diversity\n    else {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}", "15": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Probabilistic rephasing based on different criteria and solver's state\n    int phase_rand = rand() % 100;\n    // Calculate the moving average of the LBDs for fast and slow windows\n    double fast_lbd_avg = lbd_queue_size > 0 ? fast_lbd_sum / (double)lbd_queue_size : 0;\n    double slow_lbd_avg = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    // Calculate the trend of the LBD values over recent conflicts\n    double lbd_trend = lbd_queue_size >= 2 ? (lbd_queue[lbd_queue_pos == 0 ? 49 : lbd_queue_pos - 1] - lbd_queue[(lbd_queue_pos + 49) % 50]) / 2.0 : 0;\n    // Adaptive threshold based on the solver's progress\n    double adaptive_threshold = 1.0 + 0.01 * conflicts;\n\n    // Strategy 1: With a probability of 35%, use the current best phases if LBD trend is negative (improving)\n    if (lbd_trend < 0 && (phase_rand -= 35) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 25%, invert the current best phases if LBD average is not improving and trend is not negative\n    else if (fast_lbd_avg >= slow_lbd_avg && lbd_trend >= 0 && (phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 20%, rephase based on variable activity, LBD values, and adaptive threshold\n    else if ((phase_rand -= 20) < 0) {\n        for (int i = 1; i <= vars; i++) {\n            saved[i] = (activity[i] > adaptive_threshold || (fast_lbd_avg > 2.5 && slow_lbd_avg > 2.5)) ? -saved[i] : saved[i];\n        }\n    }\n    // Strategy 4: With a probability of 20%, rephase randomly to introduce more diversity\n    else {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}"}}