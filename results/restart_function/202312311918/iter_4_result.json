{"time": {"17": 1027.5, "19": 863.5, "20": 932.5}, "prompt": {"17": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Probabilistic rephasing based on different criteria and solver's state\n    int phase_rand = rand() % 100;\n    // Calculate the moving average of the LBDs for fast and slow windows\n    double fast_lbd_avg = lbd_queue_size > 0 ? fast_lbd_sum / (double)lbd_queue_size : 0;\n    double slow_lbd_avg = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    // Calculate the exponential moving average (EMA) of the LBDs for the fast window\n    double lbd_ema = 0;\n    double alpha = 0.1; // Smoothing factor\n    for (int i = 0; i < lbd_queue_size; ++i) {\n        lbd_ema = alpha * lbd_queue[i] + (1 - alpha) * lbd_ema;\n    }\n\n    // Strategy 1: With a probability of 25%, use the current best phases if fast LBD EMA is better than slow LBD average\n    if (lbd_ema < slow_lbd_avg && (phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 25%, invert the current best phases if fast LBD EMA is not improving\n    else if (lbd_ema >= slow_lbd_avg && (phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 25%, rephase based on variable activity and LBD EMA\n    else if ((phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) {\n            saved[i] = (activity[i] > 1e4 || lbd_ema > 2.5) ? -saved[i] : saved[i];\n        }\n    }\n    // Strategy 4: With a probability of 25%, rephase randomly to introduce more diversity\n    else {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}", "19": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Probabilistic rephasing based on different criteria and solver's state\n    int phase_rand = rand() % 100;\n    // Calculate the moving average of the LBDs for fast and slow windows\n    double fast_lbd_avg = lbd_queue_size > 0 ? fast_lbd_sum / (double)lbd_queue_size : 0;\n    double slow_lbd_avg = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    // Introduce a new heuristic based on the ratio of fast/slow LBD averages\n    double lbd_ratio = slow_lbd_avg > 0 ? fast_lbd_avg / slow_lbd_avg : 0;\n\n    // Strategy 1: With a probability of 30%, use the current best phases if the LBD ratio is below a threshold, indicating improvement\n    if (lbd_ratio < 0.8 && (phase_rand -= 30) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 25%, invert the current best phases if the LBD ratio is above a threshold, indicating stagnation\n    else if (lbd_ratio >= 0.8 && (phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 15%, rephase based on variable activity and a dynamic threshold that adapts to the number of conflicts\n    else if ((phase_rand -= 15) < 0) {\n        double dynamic_threshold = 1e4 * (1.0 + 0.001 * conflicts);\n        for (int i = 1; i <= vars; i++) {\n            saved[i] = (activity[i] > dynamic_threshold) ? -saved[i] : saved[i];\n        }\n    }\n    // Strategy 4: With a probability of 30%, rephase randomly to introduce more diversity, especially when other strategies are not effective\n    else {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}", "20": "void Solver::restart() {\n    // Reset the LBD related values\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Probabilistic rephasing based on different criteria and solver's state\n    int phase_rand = rand() % 100;\n    // Calculate the moving average of the LBDs for fast and slow windows\n    double fast_lbd_avg = lbd_queue_size > 0 ? fast_lbd_sum / (double)lbd_queue_size : 0;\n    double slow_lbd_avg = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    // Calculate the variance of the LBDs in the fast window\n    double lbd_variance = 0;\n    if (lbd_queue_size > 1) {\n        double lbd_mean = fast_lbd_sum / (double)lbd_queue_size;\n        for (int i = 0; i < lbd_queue_size; ++i) {\n            lbd_variance += (lbd_queue[i] - lbd_mean) * (lbd_queue[i] - lbd_mean);\n        }\n        lbd_variance /= lbd_queue_size;\n    }\n\n    // Strategy 1: With a probability of 30%, use the current best phases if fast LBD average is better than slow LBD average and variance is low\n    if (fast_lbd_avg < slow_lbd_avg && lbd_variance < 0.5 && (phase_rand -= 30) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    }\n    // Strategy 2: With a probability of 25%, invert the current best phases if fast LBD average is not improving or variance is high\n    else if ((fast_lbd_avg >= slow_lbd_avg || lbd_variance >= 0.5) && (phase_rand -= 25) < 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    }\n    // Strategy 3: With a probability of 20%, rephase based on variable activity and LBD values\n    else if ((phase_rand -= 20) < 0) {\n        for (int i = 1; i <= vars; i++) {\n            saved[i] = (activity[i] > 1e4 || (fast_lbd_avg > 2.5 && slow_lbd_avg > 2.5)) ? -saved[i] : saved[i];\n        }\n    }\n    // Strategy 4: With a probability of 25%, rephase randomly to introduce more diversity\n    else {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    }\n}"}}