{
  "0": {
    "time": 13322,
    "prompt": " "
  },
  "1": {
    "time": 16348,
    "prompt": "void Solver::restart() {\n    // Reset the LBD related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    // Rephasing step with a different strategy\n    for (int i = 1; i <= vars; i++) {\n        int phase_choice = rand() % 3;\n        switch (phase_choice) {\n            case 0: saved[i] = 1; break; // Set to true\n            case 1: saved[i] = -1; break; // Set to false\n            case 2: saved[i] = (saved[i] == 1) ? -1 : 1; break; // Flip the current phase\n        }\n    }\n}"
  },
  "2": {
    "time": 15615,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    \n    // Rephasing step with a different heuristic\n    // Instead of random rephasing, we use a deterministic approach based on the number of conflicts\n    if (conflicts % 2 == 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = 1; // Set all to true\n    } else {\n        for (int i = 1; i <= vars; i++) saved[i] = -1; // Set all to false\n    }\n    \n    // Additionally, we can introduce a periodic full random rephasing\n    if (conflicts % 100 == 0) {\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1; // Full random rephasing\n    }\n}"
  },
  "3": {
    "time": 16398,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n\n    // Backtrack to the root of the search tree\n    backtrack(0);\n\n    // Rephasing step: Instead of using a probabilistic approach, we use a deterministic strategy\n    // that cycles through different rephasing strategies every time restart is called.\n    static int rephase_strategy = 0;\n    rephase_strategy = (rephase_strategy + 1) % 3;\n    switch (rephase_strategy) {\n        case 0: // Use the saved phase\n            for (int i = 1; i <= vars; i++) saved[i] = saved[i];\n            break;\n        case 1: // Invert the saved phase\n            for (int i = 1; i <= vars; i++) saved[i] = -saved[i];\n            break;\n        case 2: // Set to a random phase\n            for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n            break;\n    }\n}"
  },
  "5": {
    "time": 16475,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    \n    // Calculate the average LBD from the LBD queue\n    double avg_lbd = lbd_queue_size > 0 ? (double)fast_lbd_sum / lbd_queue_size : 0;\n    \n    // Rephasing step with a hybrid heuristic\n    if (avg_lbd < 2.0) {\n        // If the average LBD is low, it suggests good quality clauses, so we keep the current phase\n        for (int i = 1; i <= vars; i++) saved[i] = saved[i];\n    } else if (conflicts % 10 == 0) {\n        // Every 10 conflicts, we perform a full random rephasing\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    } else {\n        // Otherwise, we flip the phase of variables that have been involved in recent conflicts\n        for (int i = 1; i <= vars; i++) {\n            if (activity[i] > 0.5 * var_inc) { // Using a threshold based on variable activity\n                saved[i] = -saved[i];\n            }\n        }\n    }\n}"
  },
  "6": {
    "time": 15448,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n    \n    // Calculate the variance of the LBD values in the LBD queue\n    double lbd_mean = static_cast<double>(fast_lbd_sum) / lbd_queue_size;\n    double lbd_variance = 0;\n    for (int i = 0; i < lbd_queue_size; ++i) {\n        double diff = lbd_queue[i] - lbd_mean;\n        lbd_variance += diff * diff;\n    }\n    lbd_variance /= lbd_queue_size;\n    \n    // Rephasing step with an adaptive strategy based on LBD variance\n    if (lbd_variance > 10) { // Threshold for high variance\n        // Perform a full random rephasing when LBD variance is high\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    } else {\n        // Otherwise, use a deterministic approach based on the number of conflicts\n        if (conflicts % 2 == 0) {\n            for (int i = 1; i <= vars; i++) saved[i] = 1; // Set all to true\n        } else {\n            for (int i = 1; i <= vars; i++) saved[i] = -1; // Set all to false\n        }\n    }\n}"
  },
  "7": {
    "time": 14094,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n\n    // Rephasing step with a heuristic based on LBD values and number of conflicts\n    if (conflicts % 100 == 0) {\n        // Every 100 conflicts, perform a full random rephasing\n        for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    } else if (conflicts % 10 == 0) {\n        // Every 10 conflicts, perform a mild rephasing based on the previous best phase\n        for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    } else {\n        // Otherwise, alternate between setting all to true and all to false\n        bool phase = conflicts % 2 == 0;\n        for (int i = 1; i <= vars; i++) saved[i] = phase ? 1 : -1;\n    }\n}"
  },
  "8": {
    "time": 13740,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n\n    // Calculate the average LBD of recent conflicts\n    double average_lbd = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n\n    // Rephasing step with a combined heuristic\n    if (average_lbd < 3.0) {\n        // If the average LBD is low, it suggests that the solver is performing well, so we stick to the current phase\n        for (int i = 1; i <= vars; i++) saved[i] = saved[i];\n    } else if (average_lbd < 5.0) {\n        // If the average LBD is moderate, we flip the phase of variables with a high activity score\n        for (int i = 1; i <= vars; i++) {\n            if (activity[i] > 1e4) saved[i] = -saved[i];\n        }\n    } else {\n        // If the average LBD is high, we perform a probabilistic rephasing similar to the original function\n        int phase_rand = rand() % 100;\n        if ((phase_rand -= 60) < 0)     for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 5) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 20) < 0)for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else for (int i = 1; i <= vars; i++) saved[i] = saved[i]; // Stick to the current phase\n    }\n}"
  },
  "11": {
    "time": 13715,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n\n    // Calculate the average LBD of recent conflicts\n    double average_lbd = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    // Calculate the trend of LBD values by comparing the average of the last half of the LBD queue to the first half\n    double lbd_trend = 0;\n    if (lbd_queue_size == 50) {\n        double first_half_sum = 0, second_half_sum = 0;\n        for (int i = 0; i < 25; ++i) first_half_sum += lbd_queue[i];\n        for (int i = 25; i < 50; ++i) second_half_sum += lbd_queue[i];\n        lbd_trend = (second_half_sum / 25) - (first_half_sum / 25);\n    }\n\n    // Rephasing step with a combined heuristic based on LBD trend and frequency of conflicts\n    if (average_lbd < 3.0 && lbd_trend <= 0) {\n        // If the average LBD is low and the trend is non-increasing, it suggests that the solver is performing well, so we stick to the current phase\n        for (int i = 1; i <= vars; i++) saved[i] = saved[i];\n    } else if (average_lbd < 5.0 || lbd_trend > 0) {\n        // If the average LBD is moderate or the LBD trend is increasing, we flip the phase of variables with a high activity score\n        for (int i = 1; i <= vars; i++) {\n            if (activity[i] > 1e4) saved[i] = -saved[i];\n        }\n    } else {\n        // If the average LBD is high or the LBD trend is strongly increasing, we perform a probabilistic rephasing\n        int phase_rand = rand() % 100;\n        if ((phase_rand -= 60) < 0)     for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 5) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 20) < 0)for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else for (int i = 1; i <= vars; i++) saved[i] = saved[i]; // Stick to the current phase\n    }\n}"
  },
  "12": {
    "time": 16772,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n\n    // Calculate the exponential moving average (EMA) of LBD scores\n    double ema_lbd = 0.0;\n    double alpha = 0.1; // Smoothing factor for EMA\n    for (int i = 0; i < lbd_queue_size; ++i) {\n        ema_lbd = alpha * lbd_queue[i] + (1 - alpha) * ema_lbd;\n    }\n\n    // Rephasing step with a heuristic based on EMA of LBD\n    if (ema_lbd < 2.5) {\n        // If the EMA of LBD is low, it suggests that the solver is performing well, so we stick to the current phase\n        for (int i = 1; i <= vars; i++) saved[i] = saved[i];\n    } else if (ema_lbd < 4.0) {\n        // If the EMA of LBD is moderate, we flip the phase of variables with a high activity score\n        for (int i = 1; i <= vars; i++) {\n            if (activity[i] > 1e4) saved[i] = -saved[i];\n        }\n    } else {\n        // If the EMA of LBD is high, we perform a probabilistic rephasing with a different distribution\n        int phase_rand = rand() % 100;\n        if ((phase_rand -= 50) < 0)     for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 30) < 0)for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else for (int i = 1; i <= vars; i++) saved[i] = saved[i]; // Stick to the current phase\n    }\n}"
  },
  "15": {
    "time": 13230,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n\n    // Calculate the average LBD of recent conflicts\n    double average_lbd = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    // Calculate the variance of LBD values\n    double lbd_variance = 0;\n    if (lbd_queue_size == 50) {\n        double lbd_mean = fast_lbd_sum / 50.0;\n        for (int i = 0; i < 50; ++i) {\n            double diff = lbd_queue[i] - lbd_mean;\n            lbd_variance += diff * diff;\n        }\n        lbd_variance /= 50.0;\n    }\n\n    // Rephasing step with a heuristic based on LBD variance\n    if (average_lbd < 3.0 && lbd_variance < 1.0) {\n        // If the average LBD is low and the variance is low, it suggests that the solver is performing well and consistently, so we stick to the current phase\n        for (int i = 1; i <= vars; i++) saved[i] = saved[i];\n    } else if (average_lbd < 5.0 || lbd_variance >= 1.0) {\n        // If the average LBD is moderate or the variance is high, we flip the phase of variables with a high activity score\n        for (int i = 1; i <= vars; i++) {\n            if (activity[i] > 1e4) saved[i] = -saved[i];\n        }\n    } else {\n        // If the average LBD is high or the variance is very high, we perform a probabilistic rephasing\n        int phase_rand = rand() % 100;\n        if ((phase_rand -= 50) < 0)     for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 30) < 0)for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else for (int i = 1; i <= vars; i++) saved[i] = saved[i]; // Stick to the current phase\n    }\n}"
  },
  "16": {
    "time": 12100,
    "prompt": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n\n    // Calculate the average LBD of recent conflicts\n    double average_lbd = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n\n    // Dynamic adjustment of rephasing probabilities based on solver performance\n    int phase_rand = rand() % 100;\n    if (average_lbd >= 4.0) {\n        // If the average LBD is high, increase the probability of complete rephasing\n        if ((phase_rand -= 70) < 0)     for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else for (int i = 1; i <= vars; i++) saved[i] = saved[i]; // Minor adjustment\n    } else {\n        // If the average LBD is low, reduce the probability of complete rephasing\n        if ((phase_rand -= 50) < 0)     for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 5) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 25) < 0)for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else for (int i = 1; i <= vars; i++) saved[i] = saved[i]; // Stick to the current phase\n    }\n}"
  }
}