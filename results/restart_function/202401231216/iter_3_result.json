{"time": {"15": 13230, "16": 12100}, "prompt": {"15": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n\n    // Calculate the average LBD of recent conflicts\n    double average_lbd = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    // Calculate the variance of LBD values\n    double lbd_variance = 0;\n    if (lbd_queue_size == 50) {\n        double lbd_mean = fast_lbd_sum / 50.0;\n        for (int i = 0; i < 50; ++i) {\n            double diff = lbd_queue[i] - lbd_mean;\n            lbd_variance += diff * diff;\n        }\n        lbd_variance /= 50.0;\n    }\n\n    // Rephasing step with a heuristic based on LBD variance\n    if (average_lbd < 3.0 && lbd_variance < 1.0) {\n        // If the average LBD is low and the variance is low, it suggests that the solver is performing well and consistently, so we stick to the current phase\n        for (int i = 1; i <= vars; i++) saved[i] = saved[i];\n    } else if (average_lbd < 5.0 || lbd_variance >= 1.0) {\n        // If the average LBD is moderate or the variance is high, we flip the phase of variables with a high activity score\n        for (int i = 1; i <= vars; i++) {\n            if (activity[i] > 1e4) saved[i] = -saved[i];\n        }\n    } else {\n        // If the average LBD is high or the variance is very high, we perform a probabilistic rephasing\n        int phase_rand = rand() % 100;\n        if ((phase_rand -= 50) < 0)     for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 30) < 0)for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else for (int i = 1; i <= vars; i++) saved[i] = saved[i]; // Stick to the current phase\n    }\n}", "16": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n\n    // Calculate the average LBD of recent conflicts\n    double average_lbd = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n\n    // Dynamic adjustment of rephasing probabilities based on solver performance\n    int phase_rand = rand() % 100;\n    if (average_lbd >= 4.0) {\n        // If the average LBD is high, increase the probability of complete rephasing\n        if ((phase_rand -= 70) < 0)     for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else for (int i = 1; i <= vars; i++) saved[i] = saved[i]; // Minor adjustment\n    } else {\n        // If the average LBD is low, reduce the probability of complete rephasing\n        if ((phase_rand -= 50) < 0)     for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 5) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 25) < 0)for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else for (int i = 1; i <= vars; i++) saved[i] = saved[i]; // Stick to the current phase\n    }\n}"}}