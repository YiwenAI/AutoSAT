{"time": {"11": 13715, "12": 16772}, "prompt": {"11": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n\n    // Calculate the average LBD of recent conflicts\n    double average_lbd = conflicts > 0 ? slow_lbd_sum / (double)conflicts : 0;\n    // Calculate the trend of LBD values by comparing the average of the last half of the LBD queue to the first half\n    double lbd_trend = 0;\n    if (lbd_queue_size == 50) {\n        double first_half_sum = 0, second_half_sum = 0;\n        for (int i = 0; i < 25; ++i) first_half_sum += lbd_queue[i];\n        for (int i = 25; i < 50; ++i) second_half_sum += lbd_queue[i];\n        lbd_trend = (second_half_sum / 25) - (first_half_sum / 25);\n    }\n\n    // Rephasing step with a combined heuristic based on LBD trend and frequency of conflicts\n    if (average_lbd < 3.0 && lbd_trend <= 0) {\n        // If the average LBD is low and the trend is non-increasing, it suggests that the solver is performing well, so we stick to the current phase\n        for (int i = 1; i <= vars; i++) saved[i] = saved[i];\n    } else if (average_lbd < 5.0 || lbd_trend > 0) {\n        // If the average LBD is moderate or the LBD trend is increasing, we flip the phase of variables with a high activity score\n        for (int i = 1; i <= vars; i++) {\n            if (activity[i] > 1e4) saved[i] = -saved[i];\n        }\n    } else {\n        // If the average LBD is high or the LBD trend is strongly increasing, we perform a probabilistic rephasing\n        int phase_rand = rand() % 100;\n        if ((phase_rand -= 60) < 0)     for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 5) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 20) < 0)for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else for (int i = 1; i <= vars; i++) saved[i] = saved[i]; // Stick to the current phase\n    }\n}", "12": "void Solver::restart() {\n    // Reset the LBD-related counters\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    // Backtrack to the root of the search tree\n    backtrack(0);\n\n    // Calculate the exponential moving average (EMA) of LBD scores\n    double ema_lbd = 0.0;\n    double alpha = 0.1; // Smoothing factor for EMA\n    for (int i = 0; i < lbd_queue_size; ++i) {\n        ema_lbd = alpha * lbd_queue[i] + (1 - alpha) * ema_lbd;\n    }\n\n    // Rephasing step with a heuristic based on EMA of LBD\n    if (ema_lbd < 2.5) {\n        // If the EMA of LBD is low, it suggests that the solver is performing well, so we stick to the current phase\n        for (int i = 1; i <= vars; i++) saved[i] = saved[i];\n    } else if (ema_lbd < 4.0) {\n        // If the EMA of LBD is moderate, we flip the phase of variables with a high activity score\n        for (int i = 1; i <= vars; i++) {\n            if (activity[i] > 1e4) saved[i] = -saved[i];\n        }\n    } else {\n        // If the EMA of LBD is high, we perform a probabilistic rephasing with a different distribution\n        int phase_rand = rand() % 100;\n        if ((phase_rand -= 50) < 0)     for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n        else if ((phase_rand -= 10) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n        else if ((phase_rand -= 30) < 0)for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n        else for (int i = 1; i <= vars; i++) saved[i] = saved[i]; // Stick to the current phase\n    }\n}"}}