{
    "task": "bump_var function",
    "prompt_fpath": "advisor.txt",
    "origin_key_code": "#define value(lit) (lit > 0 ? value[lit] : -value[-lit])    // Get the value of a literal\n#define watch(id) (watches[vars + id])                      // Remapping a literal [-maxvar, +maxvar] to its watcher.\n\nclass Clause {\npublic:\n    int lbd;                    // Literal Block Distance (Gilles & Laurent, IJCAI 2009)\n    std::vector<int> lit;       // Literals in this clause\n    Clause(int sz): lbd(0) { lit.resize(sz); }\n    int& operator [] (int index) { return lit[index]; }\n};\n\nclass Watcher {\npublic:\n    int idx_clause              // The clause index in clause database.\n        , blocker;              // Used to fast guess whether a clause is already satisfied.\n    Watcher(): idx_clause(0), blocker(0) {}\n    Watcher(int c, int b): idx_clause(c), blocker(b) {}\n};\n\nint Solver::add_clause(std::vector<int> &c) {\n    clause_DB.push_back(Clause(c.size()));                          // Add a clause c into database.\n    int id = clause_DB.size() - 1;                                  // Getting clause index.\n    for (int i = 0; i < (int)c.size(); i++) clause_DB[id][i] = c[i];     // Copy literals\n    watch(-c[0]).push_back(Watcher(id, c[1]));                      // Watch this clause by literal -c[0]\n    watch(-c[1]).push_back(Watcher(id, c[0]));                      // Watch this clause by literal -c[1]\n    return id;\n}\n\n\nvoid Solver::bump_var(int var, double coeff) {\n    if ((activity[var] += var_inc * coeff) > 1e100) {           // Update score and prevent float overflow\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100;}\n    if (vsids.inHeap(var)) vsids.update(var);                 // update heap\n}\n\nvoid Solver::assign(int lit, int l, int cref) {\n    int var = abs(lit);\n    value[var]  = lit > 0 ? 1 : -1;\n    level[var]  = l, reason[var] = cref;\n    trail.push_back(lit);\n}\n\nint Solver::propagate() {\n    while (propagated < (int)trail.size()) {\n        int p = trail[propagated++];                    // Pick an unpropagated literal in trail.\n        std::vector<Watcher> &ws = watch(p);            // Fetch the watcher for this literal.\n        int i, j, size = ws.size();\n        for (i = j = 0; i < size; ) {\n            int blocker = ws[i].blocker;\n            if (value(blocker) == 1) {                  // Pre-judge whether the clause is already SAT\n                ws[j++] = ws[i++]; continue;\n            }\n            int cref = ws[i].idx_clause, k, sz;\n            Clause& c = clause_DB[cref];                // Fetch a clause from watcher\n            if (c[0] == -p) c[0] = c[1], c[1] = -p;     // Make sure c[1] is the false literal (-p).\n            Watcher w = Watcher(cref, c[0]);            // Prepare a new watcher for c[1]\n            i++;\n            if (value(c[0]) == 1) {                     // Check whether another lit is SAT.\n                ws[j++] = w; continue;\n            }\n            for (k = 2, sz = c.lit.size(); k < sz && value(c[k]) == -1; k++);    // Find a new watch literal.\n            if (k < sz) {                               // Move the watch literal to the second place\n                c[1] = c[k], c[k] = -p;\n                watch(-c[1]).push_back(w);\n            }\n            else {                                      // Can not find a new watch literl\n                ws[j++] = w;\n                if (value(c[0]) == -1) {                // There is a confliction\n                    while (i < size) ws[j++] = ws[i++];\n                    ws.resize(j);\n                    return cref;\n                }\n                else assign(c[0], level[abs(p)], cref);// Find a new unit clause and assign it.\n            }\n        }\n        ws.resize(j);\n    }\n    return -1;                                          // Meet a convergence\n}\n\nint Solver::analyze(int conflict, int &backtrackLevel, int &lbd) {\n    ++time_stamp;\n    learnt.clear();\n    Clause &c = clause_DB[conflict];\n    int highestLevel = level[abs(c[0])];\n    if (highestLevel == 0) return 20;\n    learnt.push_back(0);        // leave a place to save the First-UIP\n    std::vector<int> bump;      // The variables to bump\n    int should_visit_ct = 0,    // The number of literals that have not been visited in the higest level of the implication graph.\n        resolve_lit = 0,        // The literal to do resolution.\n        index = trail.size() - 1;\n    do {\n        Clause &c = clause_DB[conflict];\n        for (int i = (resolve_lit == 0 ? 0 : 1); i < (int)c.lit.size(); i++) {\n            int var = abs(c[i]);\n            if (mark[var] != time_stamp && level[var] > 0) {\n                bump_var(var, 0.5);\n                bump.push_back(var);\n                mark[var] = time_stamp;\n                if (level[var] >= highestLevel) should_visit_ct++;\n                else learnt.push_back(c[i]);\n            }\n        }\n        do {                                         // Find the last marked literal in the trail to do resolution.\n            while (mark[abs(trail[index--])] != time_stamp);\n            resolve_lit = trail[index + 1];\n        } while (level[abs(resolve_lit)] < highestLevel);\n        conflict = reason[abs(resolve_lit)], mark[abs(resolve_lit)] = 0, should_visit_ct--;\n    } while (should_visit_ct > 0);                   // Have find the convergence node in the highest level (First UIP)\n    learnt[0] = -resolve_lit;\n    ++time_stamp, lbd = 0;\n    for (int i = 0; i < (int)learnt.size(); i++) {   // Calculate the LBD.\n        int l = level[abs(learnt[i])];\n        if (l && mark[l] != time_stamp)\n            mark[l] = time_stamp, ++lbd;\n    }\n    if (lbd_queue_size < 50) lbd_queue_size++;       // update fast-slow.\n    else fast_lbd_sum -= lbd_queue[lbd_queue_pos];\n    fast_lbd_sum += lbd, lbd_queue[lbd_queue_pos++] = lbd;\n    if (lbd_queue_pos == 50) lbd_queue_pos = 0;\n    slow_lbd_sum += (lbd > 50 ? 50 : lbd);\n    if (learnt.size() == 1) backtrackLevel = 0;\n    else {                                           // find the second highest level for backtracking.\n        int max_id = 1;\n        for (int i = 2; i < (int)learnt.size(); i++)\n            if (level[abs(learnt[i])] > level[abs(learnt[max_id])]) max_id = i;\n        int p = learnt[max_id];\n        learnt[max_id] = learnt[1], learnt[1] = p, backtrackLevel = level[abs(p)];\n    }\n    for (int i = 0; i < (int)bump.size(); i++)       // heuristically bump some variables.\n        if (level[bump[i]] >= backtrackLevel - 1) bump_var(bump[i], 1);\n    return 0;\n}\n\nvoid Solver::backtrack(int backtrackLevel) {\n    if ((int)pos_in_trail.size() <= backtrackLevel) return;\n    for (int i = trail.size() - 1; i >= pos_in_trail[backtrackLevel]; i--) {\n        int v = abs(trail[i]);\n        value[v] = 0, saved[v] = trail[i] > 0 ? 1 : -1; // phase saving\n        if (!vsids.inHeap(v)) vsids.insert(v);          // update heap\n    }\n    propagated = pos_in_trail[backtrackLevel];\n    trail.resize(propagated);\n    pos_in_trail.resize(backtrackLevel);\n}\n\nint Solver::decide() {\n    int next = -1;\n    while (next == -1 || value(next) != 0) {    // Picking a variable according to VSIDS\n        if (vsids.empty()) return 10;\n        else next = vsids.pop();\n    }\n    pos_in_trail.push_back(trail.size());\n    if (saved[next]) next *= saved[next];       // Pick the polarity of the varible\n    assign(next, pos_in_trail.size(), -1);\n    return 0;\n}\n\nvoid Solver::restart() {\n    fast_lbd_sum = lbd_queue_size = lbd_queue_pos = 0;\n    backtrack(0);\n    int phase_rand = rand() % 100;              // probabilistic rephasing\n    if ((phase_rand -= 60) < 0)     for (int i = 1; i <= vars; i++) saved[i] = local_best[i];\n    else if ((phase_rand -= 5) < 0) for (int i = 1; i <= vars; i++) saved[i] = -local_best[i];\n    else if ((phase_rand -= 20) < 0)for (int i = 1; i <= vars; i++) saved[i] = rand() % 2 ? 1 : -1;\n    else ;\n}\n\nvoid Solver::rephase() {\n    rephases = 0, threshold *= 0.9, rephase_limit += 8192;\n}\n\nvoid Solver::reduce() {\n    backtrack(0);\n    reduces = 0, reduce_limit += 512;\n    int new_size = origin_clauses, old_size = clause_DB.size();\n    reduce_map.resize(old_size);\n    for (int i = origin_clauses; i < old_size; i++) {    // random delete 50% bad clauses (LBD>=5)\n        if (clause_DB[i].lbd >= 5 && rand() % 2 == 0) reduce_map[i] = -1;  // remove clause\n        else {\n            if (new_size != i) clause_DB[new_size] = clause_DB[i];\n            reduce_map[i] = new_size++;\n        }\n    }\n    clause_DB.resize(new_size, Clause(0));\n    for (int v = -vars; v <= vars; v++) {   // Update the watches.\n        if (v == 0) continue;\n        int old_sz = watch(v).size(), new_sz = 0;\n        for (int i = 0; i < old_sz; i++) {\n            int old_idx = watch(v)[i].idx_clause;\n            int new_idx = old_idx < origin_clauses ? old_idx : reduce_map[old_idx];\n            if (new_idx != -1) {\n                watch(v)[i].idx_clause = new_idx;\n                if (new_sz != i) watch(v)[new_sz] = watch(v)[i];\n                new_sz++;\n            }\n        }\n        watch(v).resize(new_sz);\n    }\n}\n\nint Solver::solve() {\n    int res = 0;\n    while (!res) {\n        int cref = propagate();                         // Boolean Constraint Propagation (BCP)\n        if (cref != -1) {                               // Find a conflict\n            int backtrackLevel = 0, lbd = 0;\n            res = analyze(cref, backtrackLevel, lbd);   // Conflict analyze\n            if (res == 20) break;                       // Find a conflict in 0-level\n            backtrack(backtrackLevel);                  // backtracking\n            if (learnt.size() == 1) assign(learnt[0], 0, -1);   // Learnt a unit clause.\n            else {\n                int cref = add_clause(learnt);                  // Add a clause to data base.\n                clause_DB[cref].lbd = lbd;\n                assign(learnt[0], backtrackLevel, cref);        // The learnt clause implies the assignment of the UIP variable.\n            }\n            var_inc *= (1 / 0.8);                               // var_decay for locality\n            ++restarts, ++conflicts, ++rephases, ++reduces;\n            if ((int)trail.size() > threshold) {                // update the local-best phase\n                threshold = trail.size();\n                for (int i = 1; i <= vars; i++) local_best[i] = value[i];\n            }\n        }\n        else if (reduces >= reduce_limit) reduce();\n        else if (lbd_queue_size == 50 && 0.8 * fast_lbd_sum / lbd_queue_size > slow_lbd_sum / conflicts) restart();\n        else if (rephases >= rephase_limit) rephase();\n        else res = decide();\n    }\n    return res;\n}\n\n\nint main(int argc, char **argv) {\n    Solver S;\n    std::string folderPath = \"../data/easy/\";\n\n    int res = S.parse(argv[1]);\n    if (res == 20) printf(\"s UNSATISFIABLE\n\");\n    else {\n        res = S.solve();\n        if (res == 10) {\n            printf(\"s SATISFIABLE\n\");\n            // S.printModel();\n        }\n        else if (res == 20) printf(\"s UNSATISFIABLE\n\");\n    }\n\n    return 0;\n}\n",
    "origin_target_code": "void Solver::bump_var(int var, double coeff) {\n    if ((activity[var] += var_inc * coeff) > 1e100) {           // Update score and prevent float overflow\n        for (int i = 1; i <= vars; i++) activity[i] *= 1e-100;\n        var_inc *= 1e-100;}\n    if (vsids.inHeap(var)) vsids.update(var);                 // update heap\n}"
}